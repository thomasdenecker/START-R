################################################################################
# START-R analyzer  : a Simple tool to analyse Replication Timing with R
# Thomas DENECKER
# thomas.denecker@gmail.com
# 2020
#
# GitHub :
# https://github.com/thomasdenecker/START-R
################################################################################

################################################################################
# Library
################################################################################

library(shiny)
library(shinyFiles)
library(shinyjs)
library(shinythemes)
library(limma)
library(DNAcopy)
library(SNPchip)
library(pracma)
library(data.table)
library(htmltools)
library(clusterSim)
library(car)
library(tools)
library(stringr)

# Plot Normalisation
plot_test = read.table("test_data.txt", header = F, sep = "\t")
colnames(plot_test) = c("R","G")

#source('directoryInput.R')

options(shiny.maxRequestSize = 1000*1024^2)

ui <- tagList( useShinyjs(),
               tags$head(tags$title("START-R analyzer")),
               tags$head(tags$link(href = "PCNA.ico", rel ="shortcut icon")),
               
               HTML('<link rel="stylesheet" type="text/css" href="style.css" />'),
               
               img(src = "Logo_START_R.svg", class = "logo"),
               
               navbarPage(img(src = "PCNA.png", class = "icon"),id = "Workflow",
                          
                          
                          #==================================================
                          # Presentation
                          #==================================================
                          
                          tabPanel(title = "Workflow", value = "pres",
                                   HTML('<progress value="0" max="100"></progress>'),
                                   h1("Welcome", class= "center"),
                                   p('DNA replication is a highly regulated process involved in
                            maintaining of genome stability. It relies on a spatio-temporal program determining
                            where and when replication starts along the genome. The replication timing (RT)
                            program is finely tuned and reflects the high order organization of the metazoan
                            genome. It is clear that this program evolves with cell differentiation and cell fate.
                            Moreover aberrant DNA RT  has been reported in many diseases including cancer.', class="intro"),
                                   p('The protocol developed to study the RT of a given cell type is well established.
                            We have improved the method permitting analysis of RT of the entire genome
                            in mammalian cells. We implemented two bioinformatic tools, START-R
                            (Simple Tool for Analysis of Replication Timing with R) and START-R viewer.
                            START-R written in R language, makes it possible to analyse the data from
                            microarrays with five steps: normalization, smoothing, TTR (Timing Transition Region)
                            and CTR (Constant Timing Region) detection and finally differential analysis.
                            For each step, several options are available and selectable by the user.
                            At the end, with a classical computer configuration, the analysis takes few minutes.
                            START-R viewer is a tool that allows to visualize the data generated by
                            START-R as does a genome browser. These softwares have a user-friendly
                            interface requiring only a “simple click” and can be run under Windows,
                            Mac OS X and Linux systems without virtual machine. The script will
                            remain open to the scientific community so that the software can always be improved or developed.
                           ', class="intro"),
                                   
                                   HTML('<a href="https://thomasdenecker.github.io/START-R/"  target="_blank" class ="no_style"><button type="button" class="run">Visit website !</button></a>'),
                                   
                                   p('This web application will allow you to enter the necessary informations for
                            the analysis to run correctly. All the steps are organized
                            in workflow. Each input is checked to avoid incorrect analyses.
                           ', class="intro"),
                                   
                                   actionButton('NextS1', 'Next', class = 'intro')
                          ),
                          #==================================================
                          # Step 1 - General
                          #==================================================
                          
                          tabPanel(title = "Initialisation", value = "Step1",
                                   HTML('<progress value="17" max="100"></progress>'),
                                   HTML("<div class='CG'>"),
                                   h1("Initialisation", class ="center"),
                                   fluidRow(
                                     #column(6,
                                            #h3("Organism", class = "center"),
                                            #HTML("<div class='center'>"),
                                            #radioButtons("organism", label = NA,
                                                         #choices = list("Human (hg18)" = "Human", "No centromere" = "noCentromere", "Others (Human > hg19 or other species)" = "Other"),
                                                         #selected = "Human", inline = T),
                                            #div(id="fileOtherCentro", 
                                                #p("You can enter your own centromere position file. It
                                                                           #must be composed of 3 columns. The first must contain
                                                                           #the names of the chromosomes. They must be strictly
                                                                           #identical to those in your data files or they will be
                                                                           #ignored (START-R will consider that there is no centromere).
                                                                           #The second column corresponds to the beginning position of
                                                                           #the centromere and the third column to the end position."),
                                                #tags$br(),
                                                #fileInput("inputFileOtherCentro", label = NA)),
                                            #HTML("</div>"),
                                            #uiOutput("orga_img")
                                            
                                     #),
                                     #column(6,
                                            #h3("Differential", class = "center"),
                                            #p("Detect differences between 2 experiments", class = "center"),
                                            #HTML("<div class='center'>"),
                                            #radioButtons("dif", label = NA,
                                                         #choices = list("Yes" = "Yes", "No" = "No"),
                                                         #selected = "No", inline = T),
                                            #HTML("</div>"),
                                            #img(src= "differential.png", alt = 'dif', class = "dif")
                                            
                                     #)
                                     column(4,
                                            h3("Analysis", class = "center"),
                                            HTML("<div class='center'>"),
                                            radioButtons("analysis", label = NA,
                                                         choices = list("Microarray" = "microarray", "Repli-seq" = "repliseq"),
                                                         selected = "microarray", inline = T),
                                            div(id="SelectFiltering", 
                                                p("For Repli-seq analysis, you have to provide files with raw counts. The rpkm normalization will be performed by START-R"),
                                                radioButtons("filtering", label = NA,
                                                             choices = list("Remove lines containing 0" = "remove0", "Add a value to each line (+ 1)" = "noise"),
                                                             selected = "noise", inline = T),
                                                tags$br()),
                                            HTML("</div>")
                                     ),
                                     column(4,
                                            h3("Organism", class = "center"),
                                            HTML("<div class='center'>"),
                                            selectInput(inputId = "organism", label = "Genomes", 
                                                        choices = c("Human (hg18)" = "Human", "Human (hg19)" = "hg19", "Human (hg38)" = "hg38", "No centromere" = "noCentromere", "Others (own centromere position file or other species)" = "Other")),
                                            div(id="fileOtherCentro", 
                                                p("You can enter your own centromere position file. It
                                                                           must be composed of 3 columns. The first must contain
                                                                           the names of the chromosomes. They must be strictly
                                                                           identical to those in your data files or they will be
                                                                           ignored (START-R will consider that there is no centromere).
                                                                           The second column corresponds to the beginning position of
                                                                           the centromere and the third column to the end position."),
                                                tags$br(),
                                                fileInput("inputFileOtherCentro", label = NA)),
                                            HTML("</div>"),
                                            uiOutput("orga_img")
                                            
                                     ),
                                     column(4,
                                            h3("Differential", class = "center"),
                                            p("Detect differences between 2 experiments", class = "center"),
                                            HTML("<div class='center'>"),
                                            radioButtons("dif", label = NA,
                                                         choices = list("Yes" = "Yes", "No" = "No"),
                                                         selected = "No", inline = T),
                                            HTML("</div>"),
                                            img(src= "differential.png", alt = 'dif', class = "dif")
                                            
                                     )
                                   ),
                                   
                                   actionButton('NextS2', 'Next'),
                                   actionButton('PrevPres', 'Prev.'),
                                   HTML("</div>")
                          ),
                          #==================================================
                          # Step 2 _ Import data
                          #==================================================
                          
                          tabPanel(title = "Import data", value = "Step2",
                                   HTML('<progress value="34" max="100"></progress>'),
                                   
                                   h1("Import data"),
                                   p("In this step, you set up and select the files to import"),
                                   h2("General parameters"),
                                   tags$hr(),
                                   fluidRow(
                                     column(3,
                                            textInput(inputId= "Green_signal",
                                                      label= "Column name of green signal :",
                                                      value = "gProcessedSignal")
                                     ),
                                     
                                     column(3,
                                            textInput(inputId= "Red_signal",
                                                      label= "Column name of red signal :",
                                                      value = "rProcessedSignal", placeholder = NULL)
                                     ),
                                     
                                     column(3,
                                            radioButtons("Early_frac", "Early fraction",
                                                         choices = list("Cy3" = "Cy3", "Cy5" = "Cy5"
                                                         ),
                                                         selected = "Cy3")
                                     ),
                                     column(3,
                                            radioButtons("Late_frac", "Late fraction",
                                                         choices = list("Cy3" = "Cy3", "Cy5" = "Cy5"
                                                         ),
                                                         selected = "Cy5")
                                     )
                                     
                                   ),
                                   
                                   h2("Select file"),
                                   tags$hr(),
                                   
                                   h3("Experiment 1"),
                                   fluidRow(
                                     
                                     column(3,
                                            h4("Replica 1"),
                                            fileInput("file_E1_R1", label = NA),
                                            # Horizontal line ----
                                            tags$hr(),
                                            
                                            # Input: Checkbox if file has header ---- NOT CONNECTED
                                            radioButtons("header_E1_R1", "Header",
                                                         choices = c("Yes" = TRUE,
                                                                     "No" = FALSE),
                                                         selected = TRUE, inline=T),
                                            
                                            # Input: Select separator ----
                                            radioButtons("sep_E1_R1", "Separator",
                                                         choices = c(Comma = ",",
                                                                     Semicolon = ";",
                                                                     Tab = "\t"),
                                                         selected = "\t", inline=T),
                                            
                                            # Input: Select quotes ----
                                            radioButtons("quote_E1_R1", "Quote",
                                                         choices = c(None = "",
                                                                     "Double Quote" = '"',
                                                                     "Single Quote" = "'"),
                                                         selected = "", inline=T),
                                            
                                            # Input: Select number of rows to skip ----
                                            p(tags$b("Number of microarray information lines to skip")),
                                            numericInput("skip_E1_R1", label = NA, value = 9,
                                                         min = 0, max = 15),
                                            
                                            # Input: Select number of rows to display ----
                                            radioButtons("disp_E1_R1", "Display",
                                                         choices = c(Head = "head",
                                                                     "More (100 lines)" = "more",
                                                                     No = "no"),
                                                         selected = "head", inline=T)
                                            
                                            
                                            
                                     ),
                                     h4("Preview"),
                                     column(dataTableOutput(outputId = "contents_E1_R1"), width = 9)
                                   ),
                                   
                                   tags$hr(),
                                   
                                   fluidRow(
                                     
                                     column(3,
                                            h4("Replica 2"),
                                            fileInput("file_E1_R2", label = NA),
                                            # Horizontal line ----
                                            tags$hr(),
                                            
                                            # Input: Select number of rows to display ----
                                            radioButtons("disp_E1_R2", "Display",
                                                         choices = c(Head = "head",
                                                                     "More (100 lines)" = "more",
                                                                     No = "no"),
                                                         selected = "head", inline=T),
                                            
                                            # Input: Checkbox if file has header ---- NOT CONNECTED
                                            radioButtons("header_E1_R2", "Header",
                                                         choices = c("Yes" = TRUE,
                                                                     "No" = FALSE),
                                                         selected = TRUE, inline=T),
                                            
                                            # Input: Select separator ----
                                            radioButtons("sep_E1_R2", "Separator",
                                                         choices = c(Comma = ",",
                                                                     Semicolon = ";",
                                                                     Tab = "\t"),
                                                         selected = "\t", inline=T),
                                            
                                            # Input: Select quotes ----
                                            radioButtons("quote_E1_R2", "Quote",
                                                         choices = c(None = "",
                                                                     "Double Quote" = '"',
                                                                     "Single Quote" = "'"),
                                                         selected = "", inline=T),
                                            
                                            # Input: Select number of rows to skip ----
                                            p(tags$b("Number of microarray information lines to skip")),
                                            numericInput("skip_E1_R2", label = NA, value = 9,
                                                         min = 0, max = 15)
                                            
                                     ),
                                     h4("Preview"),
                                     column(dataTableOutput(outputId = "contents_E1_R2"), width = 9)
                                   ),
                                   
                                   h3("Experiment 2", id="title_E2"),
                                   
                                   fluidRow(id="row_E2_R1",
                                            
                                            column(3,
                                                   h4("Replica 1"),
                                                   fileInput("file_E2_R1", label = NA),
                                                   # Horizontal line ----
                                                   tags$hr(),
                                                   
                                                   # Input: Select number of rows to display ----
                                                   radioButtons("disp_E2_R1", "Display",
                                                                choices = c(Head = "head",
                                                                            "More (100 lines)" = "more",
                                                                            No = "no"),
                                                                selected = "head", inline=T),
                                                   
                                                   # Input: Checkbox if file has header ---- NOT CONNECTED
                                                   radioButtons("header_E2_R1", "Header",
                                                                choices = c("Yes" = TRUE,
                                                                            "No" = FALSE),
                                                                selected = TRUE, inline=T),
                                                   
                                                   # Input: Select separator ----
                                                   radioButtons("sep_E2_R1", "Separator",
                                                                choices = c(Comma = ",",
                                                                            Semicolon = ";",
                                                                            Tab = "\t"),
                                                                selected = "\t", inline=T),
                                                   
                                                   # Input: Select quotes ----
                                                   radioButtons("quote_E2_R1", "Quote",
                                                                choices = c(None = "",
                                                                            "Double Quote" = '"',
                                                                            "Single Quote" = "'"),
                                                                selected = "", inline=T),
                                                   
                                                   # Input: Select number of rows to skip ----
                                                   p(tags$b("Number of microarray information lines to skip")),
                                                   numericInput("skip_E2_R1", label = NA, value = 9,
                                                                min = 0, max = 15)
                                                   
                                            ),
                                            h4("Preview"),
                                            column(dataTableOutput(outputId = "contents_E2_R1"), width = 9)
                                   ),
                                   
                                   tags$hr(),
                                   
                                   
                                   fluidRow( id = "row_E2_R2",
                                             
                                             column(3,
                                                    h4("Replica 2"),
                                                    fileInput("file_E2_R2", label = NA),
                                                    # Horizontal line ----
                                                    tags$hr(),
                                                    
                                                    # Input: Select number of rows to display ----
                                                    radioButtons("disp_E2_R2", "Display",
                                                                 choices = c(Head = "head",
                                                                             "More (100 lines)" = "more",
                                                                             No = "no"),
                                                                 selected = "head", inline=T),
                                                    
                                                    # Input: Checkbox if file has header ---- NOT CONNECTED
                                                    radioButtons("header_E2_R2", "Header",
                                                                 choices = c("Yes" = TRUE,
                                                                             "No" = FALSE),
                                                                 selected = TRUE, inline=T),
                                                    
                                                    # Input: Select separator ----
                                                    radioButtons("sep_E2_R2", "Separator",
                                                                 choices = c(Comma = ",",
                                                                             Semicolon = ";",
                                                                             Tab = "\t"),
                                                                 selected = "\t", inline=T),
                                                    
                                                    # Input: Select quotes ----
                                                    radioButtons("quote_E2_R2", "Quote",
                                                                 choices = c(None = "",
                                                                             "Double Quote" = '"',
                                                                             "Single Quote" = "'"),
                                                                 selected = "", inline=T),
                                                    
                                                    # Input: Select number of rows to skip ----
                                                    p(tags$b("Number of microarray information lines to skip")),
                                                    numericInput("skip_E2_R2", label = NA, value = 9,
                                                                 min = 0, max = 15)
                                                    
                                             ),
                                             h4("Preview"),
                                             column(dataTableOutput(outputId = "contents_E2_R2"), width = 9)
                                   ),
                                   
                                   
                                   actionButton('NextS3', 'Next'),
                                   actionButton('PrevS1', 'Prev.')
                                   
                          ),
                          
                          #==================================================
                          # Step 3 - Normalisation
                          #==================================================
                          
                          tabPanel(title = "Normalisation", value = "Step3",
                                   HTML('<progress value="51" max="100"></progress>'),
                                   h1("Normalisation"),
                                   p("In this step, you can choose the types of normalizations
                            you want to apply to your data."),
                                   
                                   h2("Intra array"),
                                   tags$hr(),
                                   p("Correction of global intensities in a microarray."),
                                   fluidRow(
                                     column(3,radioButtons("RBintra_array", h4("Methods"),
                                                           choices = list("loess" = "loess", "control" = "control",
                                                                          "composite" = "composite",
                                                                          "printtiploess" = "printtiploess",
                                                                          "median" = "median", "none" = "none",
                                                                          "robustspline" = "robustspline"
                                                           ),
                                                           selected = "loess")),
                                     column(9,
                                            h4("Description"),
                                            textOutput("Intra_array_description")
                                     )
                                   ),
                                   
                                   h2("Inter replica"),
                                   tags$hr(),
                                   p("Standardization of replicates to make them comparable."),
                                   fluidRow(
                                     column(3,radioButtons("RBinter_replica", h4("Methods"),
                                                           choices = list("scale"= "scale",
                                                                          "quantile" = "quantile",
                                                                          "none" = "none", "cyclicloess" = "cyclicloess" ),
                                                           selected = "scale")),
                                     column(9,
                                            h4("Description"),
                                            textOutput("Inter_replica_description")
                                     )
                                   ),
                                   
                                   h2("Inter experiment"),
                                   tags$hr(),
                                   p("With START-R, it is possible to compare two experiments. However, from one microarray
                            to another, the quantity of material deposited or the quality of marking may differ.
                            In order to make the most accurate comparisons possible, a standardization between
                            the data from the two experiments is proposed in order to limit this type of experimental bias."),
                                   fluidRow(
                                     column(3,radioButtons("RBinter_experience", h4("Methods"),
                                                           choices = list("standardization" = "n1",
                                                                          "without normalization" = "n0",
                                                                          "unitization" = "n3"),
                                                           selected = "n1")),
                                     column(9,
                                            h4("Description"),
                                            textOutput("Inter_experience_description")
                                     )
                                   ),
                                   
                                   
                                   actionButton('NextS4', 'Next'),
                                   actionButton('PrevS2', 'Prev.')
                                   
                          ),
                          
                          #==================================================
                          # Slide 4 - Analysis
                          #==================================================
                          
                          tabPanel(title = "Analysis ", value = "Step4",
                                   HTML('<progress value="67" max="100"></progress>'),
                                   h1("Analysis Parameters"),
                                   p("In this step, you can set up the different steps of the analysis."),
                                   fluidRow(class="row-line",
                                            column(2,h4("Steps")),
                                            column(2, h4("Objective")),
                                            column(2, h4("Method")),
                                            column(3,h4("Method description")),
                                            column(3,h4("Additional options"))
                                   ),
                                   
                                   fluidRow(class="row-line",
                                            column(2,checkboxInput("CH_Smooth", label = tags$b("Smooth"), value = TRUE)),
                                            
                                            column(2, p("The smoothing step will generate a curve that will try, depending on the algorithm used,
                                       to be the most representative of this cloud of points. Once again, START-R allows the user
                                       to choose several smoothing functions.")),
                                            
                                            column(2,selectInput("select_method_smmoth", label = NA,
                                                                 choices = list("Loess" = "Loess",
                                                                                "Simple" = "s",
                                                                                "Triangular" = "t",
                                                                                "Weighted" = "w",
                                                                                "Modified" = "m",
                                                                                "Exponential" = "e",
                                                                                "Running" = "r"
                                                                 ),
                                                                 selected = "loess")
                                            ),
                                            column(3,
                                                   p(textOutput("Smooth_method_description"))
                                            ),
                                            
                                            column(3,
                                                   tags$b("Span :"),
                                                   p("The parameter alpha which controls the degree of smoothing.Fitting is done locally.
                                    That is, for the fit at point x, the fit is made using points in a neighbourhood
                                    of x, weighted by their distance from x (with differences in 'parametric' variables
                                    being ignored when computing the distance). The size of the neighbourhood is controlled
                                    by alpha (set by span or enp.target). For alpha < 1, the neighbourhood includes proportion alpha of
                                    the points, and these have tricubic weighting (proportional to (1 - (dist/maxdist)^3)^3).
                                    For alpha > 1, all points are used, with the 'maximum distance' assumed to be alpha^(1/p)
                                    times the actual maximum distance for p explanatory variables."),
                                                   sliderInput("span_slider", label = NA,
                                                               min = 100000, max = 10000000,
                                                               step = 100000,
                                                               value = 500000)
                                            )
                                            
                                   ),
                                   
                                   
                                   fluidRow(class="row-line",
                                            column(2,checkboxInput("CH_TTR", label = tags$b("TTR"), value = TRUE)),
                                            
                                            column(2,
                                                   p("The curves obtained, after smoothing from DNA chip data, show 'flat' areas
                                      that replicate either early or late, called CTRs for Constant Timing Regions.
                                    Between an early and a late zone, there is a transition zone called TTR for
                                    Timing Transition Region."))
                                            
                                   ),
                                   fluidRow(class="row-line",
                                            column(2,checkboxInput("CH_segmentation", label = tags$b("Segmentation"), value = TRUE)),
                                            
                                            column(2, p("Detection of Constant Timing Regions with TTR information")),
                                            
                                            column(2),
                                            column(3),
                                            
                                            column(3,
                                                   tags$b("Standard deviation:"),
                                                   p("The number of SDs between means to keep a split"),
                                                   sliderInput("SD_slider", label = NA,
                                                               min = 1, max = 10,
                                                               step = 0.1,
                                                               value = 2.5)
                                                   
                                            )
                                            
                                   ),
                                   
                                   fluidRow(id = 'analysis_fusion',class="row-line",
                                            column(2,checkboxInput("CH_Fusion", label = tags$b("Fusion"), value = TRUE)),
                                            
                                            column(2,
                                                   p("Combine result of TTR and CTR"))
                                            
                                   ),
                                   
                                   fluidRow(id = 'analysis_dif', class="row-line",
                                            column(2,checkboxInput("CH_Differential", label = tags$b("Differential"), value = TRUE)),
                                            
                                            column(2, p("Detection of differences between the two experiments. ")),
                                            
                                            column(2,selectInput("select_method_differential", label = NA,
                                                                 choices = list("Euclidean method" = "Euclidean method",
                                                                                "Mean method" = "Mean method",
                                                                                "Segment method" = "Segment method"
                                                                 ),
                                                                 selected = "Mean method")
                                            ),
                                            column(3,
                                                   p(textOutput("Differential_description"))
                                            ),
                                            
                                            
                                            column(3,
                                                  # Choose a p-value or an automatic detection
                                                   selectInput("select_method_pvalue", label = "Select a method for p-value",
                                                               choices = list("Automatic detection of p-value" = "Automatic pvalue",
                                                                              "Choose a p-value" = "Manual pvalue"),
                                                               selected = "Manual pvalue"),
                                                   selectInput("select_method_automatic", label = "Method for automatic detection",
                                                               choices = list("Euclidean distance" = "Euclidean distance",
                                                                               "Bezier curve" = "Bezier curve"),
                                                               selected = "Manual pvalue"),
                                                   tags$b("P-value threshold :", id = "PVT1"),
                                                   numericInput("num_PVT", label = NA, value = 0.05,
                                                                min = 0, max = 1),
                                                   
                                                   tags$b("Method for adjusting the Pvalue :", id = "APV1"),
                                                   selectInput("select_method_ad_PV", label = NA,
                                                               choices = list("holm" = "holm",
                                                                              "hochberg" = "hochberg",
                                                                              "hommel" = "hommel",
                                                                              "bonferroni" = "bonferroni",
                                                                              "BH" = "BH",
                                                                              "BY" = "BY",
                                                                              "fdr" = "fdr",
                                                                              "none" = "none"
                                                               ),
                                                               selected = "holm"),
                                                   p(textOutput("ad_PV_description"), id = "APV3"),
                                                   
                                                   tags$b("Windows size :", id = "WS1"),
                                                   p("Sliding window length (probes)", id = "WS2"),
                                                   numericInput("num_WS", label = NA, value = 60,
                                                                min = 10, max = 1000),
                                                   
                                                   tags$b("Overlap :", id = "Over1"),
                                                   p("Size of the overlap of the sliding window (probes)", id = "Over2"),
                                                   numericInput("num_Over", label = NA, value = 30,
                                                                min = 5, max = 500),
                                                   
                                                   tags$b("Empirical threshold :", id = "NP1"),
                                                   p("",  id = "NP2"),
                                                   numericInput("num_NP", label = NA, value = 0.45,
                                                                min = 0, max = 1),
                                                   checkboxInput("ET_CB", label = "Automatic", value = TRUE)
                                                   
                                            )
                                   ),
                                   tags$br(),tags$br(),
                                   actionButton('NextS5', 'Next'),
                                   actionButton('PrevS3', 'Prev.')
                                   
                          ),
                          #==================================================
                          # Slide 5 - Outputs
                          #==================================================
                          
                          tabPanel(title = "Outputs", value = "Step5",
                                   HTML('<progress value="84" max="100"></progress>'),
                                   h1("Outputs"),
                                   fluidRow(
                                     column(6,
                                            radioButtons("file_outputs", h3("File Outputs (positions,intensity,...)"),
                                                         choices = list(".bed" = "bed", ".txt" = "txt", "both" = "both"),
                                                         selected = "both")),
                                     column(6,
                                            radioButtons("graphical_outputs", h3("Graphical outputs"),
                                                         choices = list("Yes" = "Yes", "No" = "No"),
                                                         selected = "Yes"))
                                   ),
                                   
                                   actionButton('NextS6', 'Next'),
                                   actionButton('PrevS4', 'Prev.')
                          ),
                          #==================================================
                          # Slide 6 - Summary
                          #==================================================
                          
                          tabPanel(title = "Summary", value = "Step6",
                                   HTML('<progress value="100" max="100"></progress>'),
                                   h1("Summary"),
                                   
                                   h3("General informations"),
                                   fluidRow(
                                     column(12,
                                            textOutput("Out_orga"),
                                            textOutput("Out_dif")
                                     )),
                                   
                                   h3("Selected Files"),
                                   fluidRow(
                                     column(12,
                                            h4("Experiment 1"),
                                            h5("Replica 1"),
                                            textOutput("Out_file_E1_R1"),
                                            h5("Replica 2"),
                                            textOutput("Out_file_E1_R2"),
                                            h4("Experiment 2"),
                                            h5("Replica 1"),
                                            textOutput("Out_file_E2_R1"),
                                            h5("Replica 2"),
                                            textOutput("Out_file_E2_R2")
                                     )),
                                   
                                   h3("Normalisation"),
                                   fluidRow(column(12,
                                                   textOutput("Out_intra_array") ,
                                                   textOutput("Out_inter_replica") ,
                                                   textOutput("Out_inter_experience")
                                   )),
                                   
                                   h3("Analysis"),
                                   fluidRow(
                                     column(3,
                                            h4("Smooth"),
                                            textOutput("Out_smooth") ,
                                            textOutput("Out_smooth_method") ,
                                            textOutput("Out_smooth_span") ,
                                            textOutput("Out_smooth_size")
                                     ),
                                     column(3,
                                            h4("TTR"),
                                            textOutput("Out_TTR")
                                     ),
                                     
                                     column(3,
                                            h4("Segmentation"),
                                            textOutput("Out_segmentation") ,
                                            textOutput("Out_segmentation_SD")
                                     ),
                                     column(3,
                                            h4("Differential"),
                                            textOutput("Out_differential") ,
                                            textOutput("Out_differential_method") ,
                                            textOutput("Out_differential_PVT") ,
                                            textOutput("Out_differential_PVAD"),
                                            textOutput("Out_differential_NP"),
                                            textOutput("Out_differential_Over"),
                                            textOutput("Out_differential_WS")
                                     )
                                   ),
                                   
                                   h3("Outputs"),
                                   fluidRow(
                                     column(12,
                                            textOutput("Out_outputs_folder") ,
                                            textOutput("Out_outputs_file") ,
                                            textOutput("Out_outputs_graphical")
                                     )
                                   ),
                                   actionButton('Validate', 'Validate'),
                                   actionButton('PrevS5', 'Prev.')
                          ),
                          
                          #==================================================
                          # Slide 6 - Processing/ENd
                          #==================================================
                          tabPanel(title = "Job", value = "Job",
                                   
                                   h1('Click to run analysis', id = "H1_Run", align = "center"),
                                   actionButton('Run', 'Run !', class="run"),
                                   
                                   h1('Processing', id = "H1_processing", align = "center"),
                                   img(src = "process.gif", class = "process", id = "img_processing"),
                                   
                                   
                                   h1('The analysis was successful!', id = "End", align = "center"),
                                   #img(src = "end.gif", class = "end", id = "img_end")
                                   HTML('<div class="checkmark" id = "img_end">
                              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                              viewBox="0 0 161.2 161.2" enable-background="new 0 0 161.2 161.2" xml:space="preserve">
                              <path class="path" fill="none" stroke="#31B404" stroke-miterlimit="10" d="M425.9,52.1L425.9,52.1c-2.2-2.6-6-2.6-8.3-0.1l-42.7,46.2l-14.3-16.4
                              c-2.3-2.7-6.2-2.7-8.6-0.1c-1.9,2.1-2,5.6-0.1,7.7l17.6,20.3c0.2,0.3,0.4,0.6,0.6,0.9c1.8,2,4.4,2.5,6.6,1.4c0.7-0.3,1.4-0.8,2-1.5
                              c0.3-0.3,0.5-0.6,0.7-0.9l46.3-50.1C427.7,57.5,427.7,54.2,425.9,52.1z"/>
                              <circle class="path" fill="none" stroke="#31B404" stroke-width="4" stroke-miterlimit="10" cx="80.6" cy="80.6" r="62.1"/>
                              <polyline class="path" fill="none" stroke="#31B404" stroke-width="6" stroke-linecap="round" stroke-miterlimit="10" points="113,52.8
                              74.1,108.4 48.2,86.4 "/>

                              <circle class="spin" fill="none" stroke="#31B404" stroke-width="4" stroke-miterlimit="10" stroke-dasharray="12.2175,12.2175" cx="80.6" cy="80.6" r="73.9"/>

                              </svg>
                              ')
                                   
                          )
               )
)

###################################################################################################
# Server
###################################################################################################


server <- function(input, output, session) {
  
  #=============================================================================
  # Directory
  #=============================================================================
  
  # dir
  shinyDirChoose(input, 'dir', roots = c(home = '~'), filetypes = c('', 'txt'))
  dir <- reactive(input$dir)
  output$dir <- renderPrint(dir())
  
  # path
  path1 <- reactive({
    home <- normalizePath("~")
    file.path(home, paste(unlist(dir()$path[-1]), collapse = .Platform$file.sep))
  })
  
  # files
  output$files <- renderPrint(list.files(path()))
  
  #========================================
  # Hide tabset when page is init
  #========================================
  
  observe({
    hideTab(inputId = "Workflow", target = "Step1")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Step2")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Step3")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Step4")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Step5")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Step6")
  })
  
  observe({
    hideTab(inputId = "Workflow", target = "Job")
  })
  
  observe({
    hideElement(id = "H1_processing")
  })
  
  observe({
    hideElement(id = "img_processing")
  })
  
  observe({
    hideElement(id = "End")
  })
  
  observe({
    hideElement(id = "img_end")
  })
  
  observe({
    hideElement(id = "Ad_file_box")
  })
  
  
  #=============================================================================
  # Button Nav workflow
  #=============================================================================
  
  #-----------------------------------------------------------------------------
  # Pres
  #-----------------------------------------------------------------------------
  
  observeEvent(input$NextS1, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step1")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step1")
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 1
  #-----------------------------------------------------------------------------
  observeEvent(input$NextS2, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step2")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step2")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$PrevPres, {
    updateTabsetPanel(session, "Workflow",
                      selected = "pres")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 2
  #-----------------------------------------------------------------------------
  observeEvent(input$PrevS1, {
    updateTabsetPanel(session, "Workflow",
                      selected = "Step1")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$NextS3, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step3")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step3")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 3
  #-----------------------------------------------------------------------------
  observeEvent(input$PrevS2, {
    updateTabsetPanel(session, "Workflow",
                      selected = "Step2")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$NextS4, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step4")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step4")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 4
  #-----------------------------------------------------------------------------
  observeEvent(input$PrevS3, {
    updateTabsetPanel(session, "Workflow",
                      selected = "Step3")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$NextS5, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step5")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step5")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 5
  #-----------------------------------------------------------------------------
  observeEvent(input$PrevS4, {
    updateTabsetPanel(session, "Workflow",
                      selected = "Step4")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$NextS6, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Step6")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Step6")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #-----------------------------------------------------------------------------
  # Step 6
  #-----------------------------------------------------------------------------
  observeEvent(input$PrevS5, {
    updateTabsetPanel(session, "Workflow",
                      selected = "Step5")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  observeEvent(input$Validate, {
    # Show next page in navbar
    showTab(inputId = "Workflow", target = "Job")
    
    # Move in this next page
    updateTabsetPanel(session, "Workflow",
                      selected = "Job")
    
    shinyjs::runjs("window.scrollTo(0, 0)")
  })
  
  #=============================================================================
  # Init
  #=============================================================================
  
  output$orga_img <- renderUI({
    img(src = paste0(input$organism, ".svg"), height = 100, class = "center")
  })
  
  observeEvent(input$analysis, {
    if(input$analysis == "repliseq"){
      showElement(id = "SelectFiltering")
    } else {
      hideElement(id = "SelectFiltering")
    }
  })

  observeEvent(input$organism, {
    if(input$organism == "Other"){
      showElement(id = "fileOtherCentro")
    } else {
      hideElement(id = "fileOtherCentro")
    }
  }
  )
  
  #=============================================================================
  # Import Data
  #=============================================================================
  
  output$contents_E1_R1 <-  renderDataTable({
    
    req(input$file_E1_R1)
    
    df <- read.csv(input$file_E1_R1$datapath,
                   header = as.logical(input$header_E1_R1),
                   sep = input$sep_E1_R1,
                   quote = input$quote_E1_R1,
                   nrows=100,
                   skip = input$skip_E1_R1
    )
    
    if(input$disp_E1_R1 == "head") {
      return(head(df))
    }
    else if(input$disp_E1_R1 == "more") {
      return(df)
    }else{
      return(NA)
    }
    
  },  options = list(scrollX = TRUE))
  
  output$contents_E1_R2 <-  renderDataTable({
    
    req(input$file_E1_R2)
    
    df <- read.csv(input$file_E1_R2$datapath,
                   header = as.logical(input$header_E1_R2),
                   sep = input$sep_E1_R2,
                   quote = input$quote_E1_R2,
                   nrows=100,
                   skip = input$skip_E1_R2
    )
    
    if(input$disp_E1_R2 == "head") {
      return(head(df))
    }
    else if(input$disp_E1_R2 == "more") {
      return(df)
    }else{
      return(NA)
    }
    
  },  options = list(scrollX = TRUE))
  
  output$contents_E2_R1 <-  renderDataTable({
    
    req(input$file_E2_R1)
    
    df <- read.csv(input$file_E2_R1$datapath,
                   header = as.logical(input$header_E2_R1),
                   sep = input$sep_E2_R1,
                   quote = input$quote_E2_R1,
                   nrows=100,
                   skip = input$skip_E2_R1
    )
    
    if(input$disp_E2_R1 == "head") {
      return(head(df))
    }
    else if(input$disp_E2_R1 == "more") {
      return(df)
    }else{
      return(NA)
    }
    
  },  options = list(scrollX = TRUE))
  
  output$contents_E2_R2 <-  renderDataTable({
    
    req(input$file_E2_R2)
    
    df <- read.csv(input$file_E2_R2$datapath,
                   header = as.logical(input$header_E2_R2),
                   sep = input$sep_E2_R2,
                   quote = input$quote_E2_R2,
                   nrows=100,
                   skip = input$skip_E2_R2
    )
    
    if(input$disp_E2_R2 == "head") {
      return(head(df))
    }
    else if(input$disp_E2_R2 == "more") {
      return(df)
    }else{
      return(NA)
    }
    
  },  options = list(scrollX = TRUE))
  
  #=============================================================================
  # Read File - Adv
  #=============================================================================
  
  observeEvent(input$Late_frac, {
    if(input$Late_frac == "Cy3"){
      updateRadioButtons(session, "Early_frac", selected = "Cy5")
    }else if(input$Late_frac == "Cy5"){
      updateRadioButtons(session, "Early_frac",selected = "Cy3")
    }
  })
  
  observeEvent(input$Early_frac, {
    if(input$Early_frac == "Cy3"){
      updateRadioButtons(session, "Late_frac",  selected = "Cy5")
    }else if(input$Early_frac == "Cy5"){
      updateRadioButtons(session, "Late_frac", selected = "Cy3")
    }
  })
  
  #=============================================================================
  # Read File - next
  #=============================================================================
  
  observe({
    if(input$dif == "No") {
      if(is.null(input$file_E1_R1) && is.null(input$file_E1_R2)){
        disable("NextS3")
      }else{
        enable("NextS3")
      }
    }else if (input$dif == "Yes") {
      if(is.null(input$file_E2_R1) && is.null(input$file_E2_R2)){
        disable("NextS3")
      }else{
        enable("NextS3")
      }
    }
    
  })
  
  #=============================================================================
  # Show/hide dif Read file
  #=============================================================================
  
  observeEvent(input$dif, {
    if(input$dif == "Yes"){
      showElement(id = "row_E2_R1")
      showElement(id = "row_E2_R2")
      showElement(id = "title_E2")
      showElement(id = "analysis_dif")
      updateCheckboxInput(session, "CH_Smooth", value = TRUE)
      updateCheckboxInput(session, "CH_TTR", value = TRUE)
      updateCheckboxInput(session, "CH_segmentation", value = TRUE)
      updateCheckboxInput(session, "CH_Fusion", value = TRUE)
      disable("CH_Smooth")
      disable("CH_TTR")
      disable("CH_segmentation")
      disable("CH_Fusion")
      
    }else{
      hideElement(id = "row_E2_R1")
      hideElement(id = "row_E2_R2")
      hideElement(id = "title_E2")
      hideElement(id = "analysis_dif")
      enable("CH_Smooth")
      enable("CH_TTR")
      enable("CH_segmentation")
      enable("CH_Fusion")
    }
  })
  
  
  #=============================================================================
  # Description - Normalisation
  #=============================================================================
  
  #-----------------------------------------------------------------------------
  # Description - Intra array
  #-----------------------------------------------------------------------------
  output$Intra_array_description <- renderText({
    
    if(input$RBintra_array == "loess"){
      'The loess normalization methods ("loess", "printtiploess" and "composite")
      were proposed by Yang et al (2001, 2002). Smyth and Speed (2003) review
      these methods and describe how the methods are implemented in the limma package,
      including choices of tuning parameters. More information on the loess control
      parameters span and iterations can be found under loessFit.'
    } else if(input$RBintra_array == "control"){
      "Oshlack et al (2004) consider the special issues that arise when a large
      proportion of probes are differentially expressed. They propose an improved
      version of composite loess normalization, which is implemented in the
      control method. This fits a global loess curve through a set
      of control spots, such as a whole-library titration series, and applies
      that curve to all the other spots."
    }else if(input$RBintra_array == "composite"){
      'The loess normalization methods ("loess", "printtiploess" and "composite")
      were proposed by Yang et al (2001, 2002). Smyth and Speed (2003) review
      these methods and describe how the methods are implemented in the limma package,
      including choices of tuning parameters. More information on the loess control
      parameters span and iterations can be found under loessFit.'
    }else if(input$RBintra_array == "printtiploess"){
      'The loess normalization methods ("loess", "printtiploess" and "composite")
      were proposed by Yang et al (2001, 2002). Smyth and Speed (2003) review
      these methods and describe how the methods are implemented in the limma package,
      including choices of tuning parameters. More information on the loess control
      parameters span and iterations can be found under loessFit.'
    }else if(input$RBintra_array == "median"){
      "Method median subtracts the weighted median from the M-values for each array"
    }else if(input$RBintra_array == "none"){
      "Method none computes M-values and A-values but does no normalization"
    }else if(input$RBintra_array == "robustspline"){
      "Method robustspline normalizes the M-values for a single microarray using robustly fitted
      regression splines and empirical Bayes shrinkage."
    }
  })
  
  #-----------------------------------------------------------------------------
  # Description - Inter replica
  #-----------------------------------------------------------------------------
  
  output$Inter_replica_description <- renderText({
    
    if(input$RBinter_replica == "scale"){
      "Scale (method='scale') scales the columns to have the same median."
    } else if(input$RBinter_replica == "quantile"){
      "Quantile normalization was originally proposed by Bolstad et al (2003)
      for Affymetrix-style single-channel arrays.
      Quantile normalization forces the entire empirical
      distribution of each column to be identical."
    }else if(input$RBinter_replica == "none"){
      "No normalization is calculated."
    }else if(input$RBinter_replica == "cyclicloess"){
      "Cyclic loess normalization was originally proposed by Bolstad et al (2003)
      for Affymetrix-style single-channel arrays. Cyclic loess normalization applies
      loess normalization to all possible pairs of arrays, usually cycling through
      all pairs several times. Cyclic loess is slower than quantile, but allows
      probe-wise weights and is more robust to unbalanced differential expression."
    }
  })
  
  #-----------------------------------------------------------------------------
  # Description - Inter experiment
  #-----------------------------------------------------------------------------
  
  # data.Normalization
  output$Inter_experience_description <- renderText({
    
    if(input$RBinter_experience == "n1"){
      "(x-mean)/sd"
    } else if(input$RBinter_experience == "n0"){
      "Without normalization"
    }else if(input$RBinter_experience == "n3"){
      "(x-mean)/range"
    }
  })
  
  #=============================================================================
  # Analysis description
  #=============================================================================
  
  #-----------------------------------------------------------------------------
  # Description - Smooth
  #-----------------------------------------------------------------------------
  
  output$Smooth_method_description <- renderText({
    
    if(input$select_method_smmoth== "Loess"){
      "Fit a polynomial surface determined by one or more numerical predictors, using local fitting."
    } else if(input$select_method_smmoth == "s"){
      "It computes the simple moving average. n indicates the number of previous
      data points used with the current data point when calculating the moving average"
    }else if(input$select_method_smmoth == "t"){
      "It computes the triangular moving average by calculating the first simple
      moving average with window width of ceil(n+1)/2; then it calculates a second
      simple moving average on the first moving average with the same window size."
    }else if(input$select_method_smmoth == "w"){
      "It calculates the weighted moving average by supplying weights for each
      element in the moving window. Here the reduction of weights follows a linear trend."
    }else if(input$select_method_smmoth == "m"){
      "It calculates the modified moving average. The first modified moving average
      is calculated like a simple moving average. Subsequent values are calculated
      by adding the new value and subtracting the last average from the resulting sum."
    }else if(input$select_method_smmoth == "e"){
      "It computes the exponentially weighted moving average. The exponential
      moving average is a weighted moving average that reduces influences by
      applying more weight to recent data points () reduction factor 2/(n+1)."
    }else if(input$select_method_smmoth == "r"){
      "This is an exponential moving average with a reduction factor of 1/n"
    }
  })
  
  #-----------------------------------------------------------------------------
  # Description - Differential
  #-----------------------------------------------------------------------------
  
  output$Differential_description <- renderText({
    
    if(input$select_method_differential == "Euclidean method"){
      "Detection of differences by calculating the difference squared"
    } else if(input$select_method_differential == "Mean method"){
      "Detection of differences by a sliding window"
    }else if(input$select_method_differential == "Segment method"){
      "Detection of differences using CTRs and TTRs information"
    }
  })
  
  #-----------------------------------------------------------------------------
  # show / hide - differential
  #-----------------------------------------------------------------------------
  
  
  observeEvent(input$select_method_differential, {
    if(input$select_method_differential == "Euclidean method"){
      hideElement(id = "select_method_pvalue")
      hideElement(id = "select_method_automatic")

      hideElement(id = "PVT1")
      hideElement(id = "num_PVT")
      
      hideElement(id = "APV1")
      hideElement(id = "APV3")
      hideElement(id = "select_method_ad_PV")
      hideElement(id = "ad_PV_description")
      
      hideElement(id = "WS1")
      hideElement(id = "WS2")
      hideElement(id = "num_WS")
      
      hideElement(id = "Over1")
      hideElement(id = "Over2")
      hideElement(id = "num_Over")
      
      showElement(id = "NP1")
      showElement(id = "NP2")
      showElement(id = "ET_CB")
      showElement(id = "num_NP")
      
    }else if(input$select_method_differential == "Mean method"){
      
      showElement(id = "select_method_pvalue")
      
      observeEvent(input$select_method_pvalue, {
        if(input$select_method_pvalue == "Automatic pvalue"){
          showElement(id = "select_method_automatic")

          hideElement(id = "PVT1")
          hideElement(id = "num_PVT")
          
          showElement(id = "APV1")
          showElement(id = "APV3")
          showElement(id = "select_method_ad_PV")
          showElement(id = "ad_PV_description")
          
          showElement(id = "WS1")
          showElement(id = "WS2")
          showElement(id = "num_WS")
          
          showElement(id = "Over1")
          showElement(id = "Over2")
          showElement(id = "num_Over")
          
          hideElement(id = "NP1")
          hideElement(id = "NP2")
          hideElement(id = "ET_CB")
          hideElement(id = "num_NP")
        }
        else if (input$select_method_pvalue == "Manual pvalue"){
          hideElement(id = "select_method_automatic")

          showElement(id = "PVT1")
          showElement(id = "num_PVT")
          
          showElement(id = "APV1")
          showElement(id = "APV3")
          showElement(id = "select_method_ad_PV")
          showElement(id = "ad_PV_description")
          
          showElement(id = "WS1")
          showElement(id = "WS2")
          showElement(id = "num_WS")
          
          showElement(id = "Over1")
          showElement(id = "Over2")
          showElement(id = "num_Over")
          
          hideElement(id = "NP1")
          hideElement(id = "NP2")
          hideElement(id = "ET_CB")
          hideElement(id = "num_NP")
        }
      })
      
    }else if (input$select_method_differential == "Segment method"){
      hideElement(id = "select_method_pvalue")
      hideElement(id = "select_method_automatic")

      hideElement(id = "PVT1")
      hideElement(id = "num_PVT")
      
      hideElement(id = "APV1")
      hideElement(id = "APV3")
      hideElement(id = "select_method_ad_PV")
      hideElement(id = "ad_PV_description")
      
      hideElement(id = "WS1")
      hideElement(id = "WS2")
      hideElement(id = "num_WS")
      
      hideElement(id = "Over1")
      hideElement(id = "Over2")
      hideElement(id = "num_Over")
      
      hideElement(id = "NP1")
      hideElement(id = "NP2")
      hideElement(id = "ET_CB")
      hideElement(id = "num_NP")
    }
  })
  
  observeEvent(input$ET_CB,
               {
                 if (input$ET_CB){
                   shinyjs::disable("num_NP")
                 } else {
                   shinyjs::enable("num_NP")
                 }
               })
  
  
  #-----------------------------------------------------------------------------
  # Description - Differential - adjusted pval
  #-----------------------------------------------------------------------------
  
  output$ad_PV_description <- renderText({
    if(input$select_method_ad_PV == "holm"){
      "The Holm, Hochberg, Hommel and Benjamini & Hochberg methods are designed to give strong control of the
      family-wise error rate.  There seems no reason to use the
      unmodified Bonferroni correction because it is dominated by Holm's
      method, which is also valid under arbitrary assumptions."
    } else if(input$select_method_ad_PV == "hochberg"){
      "Hochberg's and Hommel's methods are valid when the hypothesis
      tests are independent or when they are non-negatively associated
      (Sarkar, 1998; Sarkar and Chang, 1997).  Hommel's method is more
      powerful than Hochberg's, but the difference is usually small and
      the Hochberg p-values are faster to compute."
    }else if(input$select_method_ad_PV == "hommel"){
      "Hochberg's and Hommel's methods are valid when the hypothesis
      tests are independent or when they are non-negatively associated
      (Sarkar, 1998; Sarkar and Chang, 1997).  Hommel's method is more
      powerful than Hochberg's, but the difference is usually small and
      the Hochberg p-values are faster to compute."
    }else if(input$select_method_ad_PV == "bonferroni"){
      "The adjustment methods include the Bonferroni correction in which the p-values are multiplied by the number of comparisons."
    }else if(input$select_method_ad_PV == "BH"){
      "The method of Benjamini, Hochberg,
      and Yekutieli control the false discovery rate, the expected
      proportion of false discoveries amongst the rejected hypotheses.
      The false discovery rate is a less stringent condition than the
      family-wise error rate, so these methods are more powerful than
      the others.
      "
    }else if(input$select_method_ad_PV == "BY"){
      "The method of Benjamini, Hochberg,
        and Yekutieli control the false discovery rate, the expected
        proportion of false discoveries amongst the rejected hypotheses.
        The false discovery rate is a less stringent condition than the
        family-wise error rate, so these methods are more powerful than
        the others.
      "
    }else if(input$select_method_ad_PV == "fdr"){
      "The method of Benjamini, Hochberg,
      and Yekutieli control the false discovery rate, the expected
      proportion of false discoveries amongst the rejected hypotheses.
      The false discovery rate is a less stringent condition than the
      family-wise error rate, so these methods are more powerful than
      the others.
      "
    }else if(input$select_method_ad_PV == "none"){
      "No correction"
    }
  })
  
  #=============================================================================
  # Analysis check box
  #=============================================================================
  
  observeEvent(input$CH_Smooth, {
    if(input$CH_Smooth == FALSE){
      updateCheckboxInput(session, "CH_TTR", value = FALSE)
      updateCheckboxInput(session, "CH_segmentation", value = FALSE)
      updateCheckboxInput(session, "CH_Fusion", value = FALSE)
    }
    
  })
  
  observeEvent(input$CH_TTR, {
    if(input$CH_TTR == TRUE){
      updateCheckboxInput(session, "CH_Smooth", value = TRUE)
    }else if(input$CH_TTR == FALSE){
      updateCheckboxInput(session, "CH_segmentation", value = FALSE)
      updateCheckboxInput(session, "CH_Fusion", value = FALSE)
    }
  })
  
  
  observeEvent(input$CH_segmentation, {
    if(input$CH_segmentation == TRUE){
      updateCheckboxInput(session, "CH_Smooth", value = TRUE)
      updateCheckboxInput(session, "CH_TTR", value = TRUE)
    }else if(input$CH_segmentation == FALSE){
      updateCheckboxInput(session, "CH_Fusion", value = FALSE)
    }
  })
  
  observeEvent(input$CH_Fusion, {
    if(input$CH_Fusion == TRUE){
      updateCheckboxInput(session, "CH_Smooth", value = TRUE)
      updateCheckboxInput(session, "CH_TTR", value = TRUE)
      updateCheckboxInput(session, "CH_segmentation", value = TRUE)
    }
  })
  
  observeEvent(input$dif, {
    if(input$dif == "No"){
      updateCheckboxInput(session, "CH_Differential", value = FALSE)
    }else if(input$dif == "Yes"){
      updateCheckboxInput(session, "CH_Differential", value = TRUE)
    }
    
  })
  
  #=============================================================================
  # Summary
  #=============================================================================
  
  #-----------------------------------------------------------------------------
  # Step 1
  #-----------------------------------------------------------------------------
  
  output$Out_orga <- renderText({
    paste("Organism :", input$organism)
  })
  
  output$Out_dif <- renderText({
    paste("Differential :", input$dif)
  })
  
  #-----------------------------------------------------------------------------
  # Step 2
  #-----------------------------------------------------------------------------
  
  output$Out_file_E1_R1 <- renderText({
    paste("File name :", input$file_E1_R1$name)
  })
  
  output$Out_file_E1_R2 <- renderText({
    paste("File name :", input$file_E1_R2$name)
  })
  
  output$Out_file_E2_R1 <- renderText({
    paste("File name :", input$file_E2_R1$name)
  })
  
  output$Out_file_E2_R2 <- renderText({
    paste("File name :", input$file_E2_R2$name)
  })
  
  #-----------------------------------------------------------------------------
  # Step 3 - normalisation
  #-----------------------------------------------------------------------------
  
  output$Out_intra_array <- renderText({
    paste("Intra array :", input$RBintra_array)
  })
  
  output$Out_inter_replica <- renderText({
    paste("Inter replica :", input$RBinter_replica)
  })
  
  output$Out_inter_experience <- renderText({
    paste("Inter experiment :", input$RBinter_experience)
  })
  
  #-----------------------------------------------------------------------------
  # Step 4 - Analyse
  #-----------------------------------------------------------------------------
  
  output$Out_smooth <- renderText({
    paste("Realiazed? :", input$CH_Smooth)
  })
  
  output$Out_smooth_method <- renderText({
    paste("Method :", input$select_method_smmoth)
  })
  
  output$Out_smooth_span <- renderText({
    paste("Span :", input$span_slider)
  })
  
  output$Out_TTR <- renderText({
    paste("Realiazed? :", input$CH_TTR)
  })
  
  output$Out_segmentation <- renderText({
    paste("Realiazed? :", input$CH_segmentation)
  })
  
  output$Out_segmentation_SD <- renderText({
    paste("SD :", input$SD_slider)
  })
  
  output$Out_differential <- renderText({
    paste("Realiazed? :", input$CH_Differential)
  })
  
  output$Out_differential_method <- renderText({
    paste("Method :", input$select_method_differential)
  })
  
  output$Out_differential_PVT <- renderText({
    # Indicate the p-value in the summary
    if(input$select_method_differential == "Mean method" && input$select_method_pvalue == "Manual pvalue"){
      paste("PVT :", input$num_PVT)
    }
    # Otherwise indicate that the p-value is detected automatically
    else if(input$select_method_differential == "Mean method" && input$select_method_pvalue == "Automatic pvalue"){
        paste("PVT :", "Automatic detection of p-value")
        paste("Method of automatic detection :", input$select_method_automatic)
    }
  })
  
  output$Out_differential_PVAD <- renderText({
    if(input$select_method_differential == "Mean method"){
      paste("Method adjustment PV :", input$select_method_ad_PV)
    }
  })
  
  output$Out_differential_WS <- renderText({
    if(input$select_method_differential == "Mean method"){
      paste("Windows size:", input$num_WS)
    }
  })
  
  output$Out_differential_Over <- renderText({
    if(input$select_method_differential == "Mean method"){
      paste("Overlap:", input$num_Over)
    }
  })
  
  output$Out_differential_NP <- renderText({
    if(input$select_method_differential == "Euclidean method"){
      paste("Empirical threshold:", input$num_NP)
    }
  })
  
  output$Out_outputs_file <- renderText({
    paste("File format :", input$file_outputs)
  })
  
  output$Out_outputs_graphical <- renderText({
    paste("Graphical :", input$graphical_outputs)
  })
  
  
  #=============================================================================
  # Processing
  #=============================================================================
  
  click = FALSE
  observeEvent(input$Run , {

    ################################################################################
    # Functions : File Treatment
    ################################################################################
    
    remove.zero <- function(file.to.treat){
      nonzero.value.index.g <- rownames(file.to.treat[file.to.treat["gProcessedSignal"] == 0, ])
      nonzero.value.index.r <- rownames(file.to.treat[file.to.treat["rProcessedSignal"] == 0, ])
      #Recover all lines with 0 in " gProcessedSignal " column and / or " gProcessedSignal " column
      union.index <- unique(sort(c(as.numeric(nonzero.value.index.g), as.numeric(nonzero.value.index.r))))
      return(union.index)
    }

    remove.min.two.columns <- function(file.to.treat){
      min.gProcessedSignal <- min(file.to.treat$gProcessedSignal)
      min.rProcessedSignal <- min(file.to.treat$rProcessedSignal)
      min.value.index.g <- rownames(file.to.treat[file.to.treat["gProcessedSignal"] == min.gProcessedSignal, ])
      min.value.index.r <- rownames(file.to.treat[file.to.treat["rProcessedSignal"] == min.rProcessedSignal, ])
      # Recover all lines with min value in " gProcessedSignal " column and " gProcessedSignal " column
      intersect.min.index <- intersect(min.value.index.g, min.value.index.r)
      return(intersect.min.index)
    }
    
    # Remove "chrY"
    remove.chry <- function(file.to.treat){
      # Positions of lines with "chrY"
      pos.chry <- c()
      for (i in 1:(dim(file.to.treat)[1])){
        pos <- file.to.treat[i, "SystematicName"]
        # Recover only chr name
        pos.split <- strsplit(as.character(pos), ":")
        type.chr <- unlist(pos.split)[1]
        if (!is.na(type.chr) && type.chr == "chrY"){
          pos.chry <- c(pos.chry, i)
        }
        else{
          pos.chry <- pos.chry
        }
      }
      return(pos.chry)
    }
    
    # Treatment to avoid errors when methods are used in the app
    treatment.repliseq <- function(name, input.skip, index){
      # Read input file
      file <- read.table(name, sep = "\t", header = TRUE, skip = input.skip)

      # Determine bin size
      pos.with.chr <- str_split(file[1, "SystematicName"], ":")
      start.end <- str_split(pos.with.chr[[1]][2], "-")
      bs <- as.numeric(start.end[[1]][2]) - as.numeric(start.end[[1]][1])

      # Add noise to avoid 0 = add 1 to each value
      if (input$filtering == "noise"){
        file[, "gProcessedSignal"] <- file[, "gProcessedSignal"] + 1
        file[, "rProcessedSignal"] <- file[, "rProcessedSignal"] + 1
      }
      # Calculate RPKM values
      sum.S1 <- sum(file$gProcessedSignal)
      sum.S2 <- sum(file$rProcessedSignal)
      file$gProcessedSignal <- file$gProcessedSignal / (sum.S1 * 10**-6 * bs * 10**-3)
      file$rProcessedSignal <- file$rProcessedSignal / (sum.S2 * 10**-6 * bs * 10**-3)

      # Remove lines with min values
      file.without.min <- file[-index, ]

      # Remove "chrY"
      pos.chry <- remove.chry(file = file.without.min)
      if (!is.null(pos.chry)){
        treated.file <- file.without.min[-pos.chry,]
        write.table(treated.file, name, sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)
      }
      else{
        write.table(treated.file, name, sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)
      }
    }

    # Treatment to avoid a noise (log2(ratio) = 0) when microarray files are used
    treatment.microarray <- function(name, input.skip, index){
      # Read input file
      file <- read.table(name, sep = "\t", header = TRUE, skip = input.skip)
      treated.file <- file[-index, ]
      write.table(treated.file, name, sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)
    }

    # Rounding numbers using the digits behind the decimal point
    round.number <- function(num){
      list.num <- str_split(num, "\\.")
      arr <- list.num[[1]][2]
      if (as.numeric(str_split(arr, "")[[1]][1]) >= 5 && !is.na(arr)){
        num.new <- as.numeric(list.num[[1]][1]) + 1
      }
      if (as.numeric(str_split(arr, "")[[1]][1]) < 5 && !is.na(arr)){
        num.new <- as.numeric(list.num[[1]][1])
      }
      if (is.na(arr)){
        num.new <- as.numeric(list.num[[1]])
      }
      num.new
      return(num.new)
    }
    
    # Rounding positions of dataframe columns
    round.positions <- function(x){
      pos.start <- x[2]
      pos.end <- x[3]
      new.pos.start <- round.number(pos.start)
      new.pos.end <- round.number(pos.end)
      x[2] <- new.pos.start
      x[3] <- new.pos.end
      return(x)
    }

    # Prediction of tangent from a point
    # tangent <- function(x.tangent, smooth){
    #   pred.deriv0 <- predict(smooth, x = x.tangent, deriv = 0)
    #   # Predict ordinate for first derivative
    #   pred.deriv1 <- predict(smooth, x = x.tangent, deriv = 1)
    #   yint <- pred.deriv0$y - (pred.deriv1$y * x.tangent)
    #   xint <- - yint / pred.deriv1$y
    #   return(list(pred.deriv0, pred.deriv1, xint, yint))
    # }
    # 
    # # Calculate euclidean distance between two points
    # dist.euclid <- function(x1, x2, y1, y2){
    #   dist <- sqrt((x1 - x2)**2 + (y1 - y2)**2)
    #   return(dist)
    # }
    
    # PValuator functions
    
    # Remove a part of the data (to avoid obtaining a plateau that is too long for small p-values)
    remove.small.var <- function(df, value){
      # Remove values of the distribution when they are too close
      variance <- c()
      for (i in 1:(dim(df)[1] - 1)){
        variance <- c(variance, var(df$Percentage[1:(i+1)]))
      }
      # Keep positions of variances
      ind.var <- which(variance > (variance[length(variance)] * value))
      # Keep lines of interest : -1 to recover the previous value and +1 to recover the last value used to calculate the variance
      df <- df[(ind.var[1] - 1):(ind.var[length(ind.var)] + 1), ]
      return(df)
    }
    
    # Calculate euclidean distance between two points
    dist.euclid <- function(x1, x2, y1, y2){
      dist <- sqrt((x1 - x2)**2 + (y1 - y2)**2)
      return(dist)
    }
    
    ################################################################################
    
    # Load centromere positions for hg38 genome (table extracted from "rCGH" package : data derived from the Hg38 gap UCSC table)
    hg38 <- read.table("./Inputs/centromere_positions_hg38.txt", header = TRUE, sep = "\t")

    # Before
    hideElement(id = "Run")
    hideElement(id = "H1_Run")
    showElement(id = "H1_processing")
    showElement(id = "img_processing")
    showElement(id = "Processing")
    
    # Variable for code
    if(is.null(input$file_E1_R1$datapath)){
      File1 =  input$file_E1_R2$datapath
      File1name =  input$file_E1_R2$name
    }else{
      File1 = input$file_E1_R1$datapath
      File1name =  input$file_E1_R1$name
    }
    
    if(is.null(input$file_E1_R2$datapath)){
      File2 = input$file_E1_R1$datapath
      File2name = input$file_E1_R1$name
    }else{
      File2 = input$file_E1_R2$datapath
      File2name = input$file_E1_R2$name
    }
    
    if(is.null(input$file_E2_R1$datapath)){
      File3 = input$file_E2_R2$datapath
      File3name = input$file_E2_R2$name
    }else{
      File3 = input$file_E2_R1$datapath
      File3name = input$file_E2_R1$name
    }
    
    if(is.null(input$file_E2_R2$datapath)){
      File4 = input$file_E2_R1$datapath
      File4name = input$file_E2_R1$name
    }else{
      File4 = input$file_E2_R2$datapath
      File4name = input$file_E2_R2$name
    }
    
    nomtotal = c(File1 = File1,
                 File2 = File2,
                 File3 = File3,
                 File4 = File4)
    

    ################################################################################
    # determine the lines to be deleted according to the method to be used
    ################################################################################
    
    differential.analysis = input$CH_Differential
    union.index <- c()
    if (differential.analysis == TRUE && input$analysis == "repliseq"){
          
          # Read all input files
          file1.before.treatment <- read.table(File1, header=T, sep="\t", skip = input$skip_E1_R1)
          file2.before.treatment <- read.table(File2, header=T, sep="\t", skip = input$skip_E1_R1)
          file3.before.treatment <- read.table(File3, header=T, sep="\t", skip = input$skip_E1_R1)
          file4.before.treatment <- read.table(File4, header=T, sep="\t", skip = input$skip_E1_R1)

          nbr.total <- dim(file1.before.treatment)[1]

          if (input$filtering == "remove0"){
            union.index1 <- remove.zero(file = file1.before.treatment)
            union.index2 <- remove.zero(file = file2.before.treatment)
            union.index3 <- remove.zero(file = file3.before.treatment)
            union.index4 <- remove.zero(file = file4.before.treatment)
            
            union.index1.2 <- unique(sort(c(as.numeric(union.index1), as.numeric(union.index2))))
            union.index3.4 <- unique(sort(c(as.numeric(union.index3), as.numeric(union.index4))))
          }

          if (input$filtering == "noise"){
            inter.index1 <- remove.min.two.columns(file = file1.before.treatment)
            inter.index2 <- remove.min.two.columns(file = file2.before.treatment)
            inter.index3 <- remove.min.two.columns(file = file3.before.treatment)
            inter.index4 <- remove.min.two.columns(file = file4.before.treatment)
            
            union.index1.2 <- unique(sort(c(as.numeric(inter.index1), as.numeric(inter.index2))))
            union.index3.4 <- unique(sort(c(as.numeric(inter.index3), as.numeric(inter.index4))))
          }
          
          # Recover indices from all files in order to remove same lines (= same chromosome and positions)
          union.index <- unique(sort(c(as.numeric(union.index1.2), as.numeric(union.index3.4))))

    } 
     else if (input$analysis == "microarray"){

      nbr.lines <- input$skip_E1_R1
      file1.before.treatment <- read.table(File1, header=T, sep="\t", skip = nbr.lines)
      file2.before.treatment <- read.table(File2, header=T, sep="\t", skip = nbr.lines)
      
      lines.pos <- str_split(file1.before.treatment$SystematicName, ":")
      ind.chry <- c()
      for (i in 1:length(lines.pos)){
        if (lines.pos[[i]][1] == "chrY"){
          ind.chry <- c(ind.chry, i)
        }
      }
      
      ind.logratio.cond1 <- which(file1.before.treatment$LogRatio == 0)
      ind.logratio.cond2 <- which(file2.before.treatment$LogRatio == 0)
      union.index1.2 <- unique(sort(c(as.numeric(ind.logratio.cond1), as.numeric(ind.logratio.cond2))))
      
      nbr.total <- dim(file1.before.treatment)[1]
      nbr.remove <- length(union.index1.2)
      percentage.remove <- (nbr.remove / dim(file1.before.treatment)[1]) * 100

      if (differential.analysis == TRUE){
        file3.before.treatment <- read.table(File3, header=T, sep="\t", skip = nbr.lines)
        file4.before.treatment <- read.table(File4, header=T, sep="\t", skip = nbr.lines)
        
        ind.logratio.cond3 <- which(file3.before.treatment$LogRatio == 0)
        ind.logratio.cond4 <- which(file4.before.treatment$LogRatio == 0)
        
        union.index3.4 <- unique(sort(c(as.numeric(ind.logratio.cond3), as.numeric(ind.logratio.cond4))))
        union.index.logratio <- unique(sort(c(as.numeric(union.index1.2), as.numeric(union.index3.4))))
        union.index.all <- unique(sort(c(as.numeric(union.index.logratio), as.numeric(ind.chry))))
      }
      else{
        union.index.all <- unique(sort(c(as.numeric(union.index1.2), as.numeric(ind.chry))))
      }

      nbr.remove <- length(union.index.all)
      percentage.remove <- (nbr.remove / dim(file1.before.treatment)[1]) * 100

    }
    ################################################################################


    sortie_image = input$graphical_outputs
    bed = input$file_outputs
    nor1 = input$RBintra_array
    nor2 = input$RBinter_replica
    nor3 = input$RBinter_experience
    
    e1 = input$CH_Smooth
    e2 = input$CH_TTR
    e3 = input$CH_segmentation
    e4 = input$CH_Fusion
    e5 = input$CH_Differential
    
    v1 = input$span_slider
    v2 = input$SD_slider
    v3 = input$select_method_ad_PV
    v4 = input$select_method_smmoth
    v5 = input$num_WS
    
    fs1 = input$skip_E1_R1
    fsSep = input$sep_E1_R1
    fs2 = input$Green_signal
    fs3 = input$Red_signal
    fs4 = input$Early_frac
    fs5 = input$Late_frac
    
    pv1 = input$num_PVT
    pv2 = input$num_WS
    pv3 = input$select_method_ad_PV
    pv4 = input$num_Over
    
    type_dif = input$select_method_differential
    seuil = input$num_NP
    organisme = input$organism
    
    directory = "./Outputs"
    
    ################################################################################
    # Functions
    ################################################################################
    
    no_centro = function(chromo){
      tableau = matrix(0, 1, 2)
      colnames(tableau) = c("debut", "fin")
      rownames(tableau) = chromo
      return(tableau[which(rownames(tableau)== chromo),])
    }
    
    centro_Other = function(tableau, chromo){
      return(tableau[which(rownames(tableau)== chromo),])
    }
    
    ################################################################################
    # Constants
    ################################################################################
    
    increment = 1
    moyenne = NULL
    adresse = getwd()
    
    # Differential or not
    if (e5 == TRUE){
      tour = 2
    }else {
      tour = 1
    }
    
    ############################################################################
    # Main
    ############################################################################
    
    #///////////////////////////////////////////////////////////////////////////
    # Creating a codebook
    #///////////////////////////////////////////////////////////////////////////
    
    # codebook = NULL
    # codebook = rbind(codebook, c("File 1 : ",File1name))
    # codebook = rbind(codebook, c("File 2 : ",File2name))
    # codebook = rbind(codebook, c("File 3 : ",File3name))
    # codebook = rbind(codebook, c("File 4 : ",File4name))
    # codebook = rbind(codebook, c("Organism : ",organisme))
    # codebook = rbind(codebook, c("Sortie image : ",sortie_image))
    # codebook = rbind(codebook, c("Bed : ",bed))
    # codebook = rbind(codebook, c("Intra array : ",nor1))
    # codebook = rbind(codebook, c("Inter replica : ",nor2))
    # codebook = rbind(codebook, c("Inter experiment : ",nor3))
    # codebook = rbind(codebook, c("Smooth : ",e1))
    # codebook = rbind(codebook, c("TTR : ",e2))
    # codebook = rbind(codebook, c("Segmentation : ",e3))
    # codebook = rbind(codebook, c("All : ",e4))
    
    # codebook = rbind(codebook, c("Differential analysis : ",e5))
    
    # codebook = rbind(codebook, c("Span : ",v1))
    # codebook = rbind(codebook, c("Number of SD : ",v2))
    # codebook = rbind(codebook, c("padjust : ",v3))
    # codebook = rbind(codebook, c("Smooth method : ",v4))
    # codebook = rbind(codebook, c("Size : ",v5))
    # codebook = rbind(codebook, c("Number of lines to skip : ",fs1))
    # codebook = rbind(codebook, c("Column name of green signal : ",fs2))
    # codebook = rbind(codebook, c("Column name of red signal : ",fs3))
    # codebook = rbind(codebook, c("Early fraction : ",fs4))
    # codebook = rbind(codebook, c("Late fraction : ",fs5))

    # if(e5){
      # codebook = rbind(codebook, c("Difference type : ",type_dif))
      # if(input$select_method_differential == "Mean method" && input$select_method_pvalue == "Manual pvalue"){
        # codebook = rbind(codebook, c("P-value threshold : ",pv1))
        # codebook = rbind(codebook, c("Window size : ",pv2))
        # codebook = rbind(codebook, c("Adjusted Pvalue : ",pv3))
        # codebook = rbind(codebook, c("Overlap : ",pv4))
      # }
    # }
    
    
    #///////////////////////////////////////////////////////////////////////////
    # Creation of analysis folder
    #///////////////////////////////////////////////////////////////////////////
    
    # Today's date to name folder
    date = format(Sys.Date(), "%Y%m%d")
    dateorigine = date
    
    # Creation of a folder with the date and according to the analyses already
    # carried out during the day
    direction = paste(directory,"/", sep ="")
    setwd(direction)
    
    i = 1
    if (file.exists(date) == FALSE)
      date = paste(date,"_1",sep = "")
    
    while (file.exists(date) == TRUE){
      date = paste(dateorigine,"_",i, sep ="")
      i = i +1
    }
    
    # Create folder
    dir.create(date)
    directionf = date
    
    setwd(directionf)
    
    #///////////////////////////////////////////////////////////////////////////
    # Normalisation intra and inter replicats
    #///////////////////////////////////////////////////////////////////////////
    
    increment = 1
    
    for (z in 1:tour){
      
      cat("Script R works...")
      
      #=========================================================================
      # Analyse preparation
      #=========================================================================
      
      #-------------------------------------------------------------------------
      # Get filename of replicat
      #-------------------------------------------------------------------------
      
      nom = nomtotal[increment]
      file.copy(nom, "./")
      extension = file_ext(nom)
      if(increment == 1){
        file.rename(paste0("0.", extension), "E1_R1.txt")
        nom = "E1_R1.txt"
        # File treatment to avoid errors during differential analysis
        if (differential.analysis == TRUE  && input$analysis == "repliseq" && length(union.index) > 0){
          treatment.repliseq(name = nom, input.skip = fs1, index = union.index) 
        }
        # File treatment to avoid noise (log2(ratio) = 0)
        else if (input$analysis == "microarray" && length(union.index.all) > 0){
          treatment.microarray(name = nom, input.skip = nbr.lines, index = union.index.all)
        }
      } else{
        file.rename(paste0("0.", extension), "E2_R1.txt")
        nom = "E2_R1.txt"
        # File treatment to avoid errors during differential analysis
        if (differential.analysis == TRUE && input$analysis == "repliseq" && length(union.index) > 0){
          treatment.repliseq(name = nom, input.skip = fs1, index = union.index)
        }
        # File treatment to avoid noise (log2(ratio) = 0)
        else if (input$analysis == "microarray" && length(union.index.all) > 0){
          treatment.microarray(name = nom, input.skip = nbr.lines, index = union.index.all)
        }
      }
      
      nom2 = nomtotal[increment+1]
      extension2 = file_ext(nom2)
      file.copy(nom2, "./")
      if(increment == 1){
        file.rename(paste0("0.", extension2), "E1_R2.txt")
        nom2 = "E1_R2.txt"
        # File treatment to avoid errors during differential analysis
        if (differential.analysis == TRUE && input$analysis == "repliseq" && length(union.index) > 0){
          treatment.repliseq(name = nom2, input.skip = fs1, index = union.index) 
        }
        # File treatment to avoid noise (log2(ratio) = 0)
        else if (input$analysis == "microarray" && length(union.index.all) > 0){
          treatment.microarray(name = nom2, input.skip = nbr.lines, index = union.index.all)
        }
      } else{
        file.exp2.replicat2 <- read.table("0.txt", sep = "\t", header = TRUE, skip = input$skip_E1_R1)
        nom2 = "0.txt"
        # File treatment to avoid errors during differential analysis
        if (differential.analysis == TRUE && input$analysis == "repliseq" && length(union.index) > 0){
          treatment.repliseq(name = nom2, input.skip = fs1, index = union.index) 
        }
        # File treatment to avoid noise (log2(ratio) = 0)
        else if (input$analysis == "microarray" && length(union.index.all) > 0){
          treatment.microarray(name = nom2, input.skip = nbr.lines, index = union.index.all)
        }
      }
      
      # Change the number of lines to skip in order to read treated input files
      if (input$analysis == "microarray" && length(union.index.all) > 0){
        fs1 = 0
      }
      
      increment = 3
      
      
      nomT = removeExt(nom)
      nom2T = removeExt(nom2)
      num = substring(nom,1,4)
      
      #-------------------------------------------------------------------------
      # Analysis of Experience 1 or 2
      #-------------------------------------------------------------------------
      
      if ( z == 1){
        prefixe = "Experience_1"
      } else if (z == 2){
        prefixe = "Experience_2"
      }
      
      #-------------------------------------------------------------------------
      # Creation of subfolder
      #-------------------------------------------------------------------------
      
      dir.create(prefixe, recursive = T)
      # direction = paste(directory,"/",date,"/",prefixe, sep = "")
      direction = prefixe
      setwd(dir = direction)
      
      dir.create("Autocorrelation")
      dir.create("Chromosomes")
      dir.create("Viewer")
      if (e2 ==TRUE){
        dir.create("Segmentation")
      }
      if (e1 == TRUE){
        dir.create("Smooth")
      }
      dir.create("Normalisation")
      dir.create("File_software")
      if (e4 == TRUE){
        dir.create("Fusion")
      }
      if (e3 == TRUE){
        dir.create("TTR")
      }
      setwd("..")
      
      #=========================================================================
      # Normalisation
      #=========================================================================
      
      #-------------------------------------------------------------------------
      # Analysis of data type
      #-------------------------------------------------------------------------
      
      filename = paste(nomT,".txt",sep="")
      filename2 = paste(nom2T,".txt",sep="")
      tab5rows <- read.table(filename,header = T, skip = fs1, sep = fsSep)
      tab5rows_sauve = tab5rows
      tab5rows2 <- read.table(filename2,header = T, skip = fs1, sep = fsSep)
      classes <- sapply(tab5rows, class)
      classes2 <- sapply(tab5rows2, class)
      
      #-------------------------------------------------------------------------
      # Data extraction
      #-------------------------------------------------------------------------
      
      mLymph1_Cy5_Cy3 <- read.table(filename,header=T,  comment.char = "",
                                    colClasses=classes, skip = fs1, sep = fsSep)
      mLymph2_Cy5_Cy3 <- read.table(filename2,header=T,  comment.char = "",
                                    colClasses=classes, skip = fs1, sep = fsSep)
      
      # Count the percentage of removed lines for repli-seq analysis
      if (differential.analysis == TRUE && input$analysis == "repliseq"){
        nbr.remove <- dim(file1.before.treatment)[1] - dim(mLymph1_Cy5_Cy3)[1]
        percentage.remove <- (nbr.remove / dim(file1.before.treatment)[1]) * 100
      }

      #-------------------------------------------------------------------------
      # Intensity extraction
      #-------------------------------------------------------------------------
      mLymph1 <- data.frame(S_Cy5 = mLymph1_Cy5_Cy3[,fs2] ,
                            S_Cy3 = mLymph1_Cy5_Cy3[,fs3])
      
      mLymph2 <- data.frame(S_Cy5 = mLymph2_Cy5_Cy3[,fs2] ,
                            S_Cy3 = mLymph2_Cy5_Cy3[,fs3])
      
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      
      nom2 = sapply(strsplit(basename(nom2),"\\."),
                    function(x) paste(x[1:(length(x)-1)], collapse="."))
      
      #-------------------------------------------------------------------------
      # Save in new format
      #-------------------------------------------------------------------------
      
      filename = paste(prefixe,"/File_software/",nom,".rgl.txt",sep="")
      write.table(mLymph1,file=filename, row.names=F, quote=F, sep="\t", eol="\r\n")
      
      if(nom == nom2){
        filename2 = paste(prefixe,"/File_software/",nom2,"2.rgl.txt",sep="")
      }else {
        filename2 = paste(prefixe,"/File_software/",nom2,".rgl.txt",sep="")
      }
      write.table(mLymph2,file=filename2, row.names=F, quote=F, sep="\t",
                  eol="\r\n")
      
      #-------------------------------------------------------------------------
      # Prepare input file for normalisation
      #-------------------------------------------------------------------------
      
      tab_T = rbind(c("SlideNumber","Name","FileName","Cy3","Cy5"),
                    c("1", "mLymph1", filename,	"late",	"early"),
                    c("2",	"mLymph2",filename2, "late","early"))
      
      filenameT = paste(prefixe,"/File_software/replicat.csv", sep ="")
      
      write.table(tab_T,file=filenameT, row.names=F, quote=F,
                  sep="\t", eol="\r\n", col.names = F)
      
      t = read.csv2(filenameT, sep="\t", header = T)
      
      #-------------------------------------------------------------------------
      # Read microarray data
      #-------------------------------------------------------------------------
      
      if (fs4 == "Cy3" & fs5 == "Cy5" ){
        r = read.maimages(t, source="generic",columns=list(R="S_Cy5", G="S_Cy3"))
      }
      
      if (fs4 == "Cy5" & fs5 == "Cy3" ){
        r = read.maimages(t, source="generic",columns=list(R="S_Cy3", G="S_Cy5"))
      }
      
      #-------------------------------------------------------------------------
      # Perform intra normalization
      #-------------------------------------------------------------------------
      
      MA.l = normalizeWithinArrays(r, method=nor1)
      
      #-------------------------------------------------------------------------
      # Perform inter replica normalization
      #-------------------------------------------------------------------------
      
      MA.q = normalizeBetweenArrays(MA.l, method=nor2)
      
      #-------------------------------------------------------------------------
      # Graphical representation of normalisation
      #-------------------------------------------------------------------------
      
      if(sortie_image == "Yes"){
        filename = paste( prefixe,"/Normalisation/",nom,"_normalisation.pdf",
                          sep ="")
        
        pdf(filename)
        
        par(oma = c(0, 1, 4, 0), mfrow = c(3, 1), mex = 0.7)
        # Raw data
        plotDensities(r, main = "Raw data", legend = "topright")
        
        # After within-array normalization
        plotDensities(MA.l, main = paste("After within-array normalization (Method :", nor1,")"),  legend = "topright")
        
        # After between-array normalization
        plotDensities(MA.q, main =paste( "After between-array normalization (Method :",nor2 ,")"),  legend = "topright")
        mtext("Distribution of spot intensities", side = 3, line = 1,
              outer = TRUE, cex = 1.5)
        
        dev.off()
      }
      
      if(sortie_image == "Yes"){
        # Dependence of timing ratios on signeal intensity
        filename = paste( prefixe,"/Normalisation/",nom,"_ratio_intensity.pdf",
                          sep ="")
        
        pdf(filename)
        
        par(oma = c(0, 0, 3, 0), mfrow = c(2, 1), mex = 0.7)
        # Raw data, replicate 1
        plotMA(r, array=1, main = "Raw data")
        # After within-array normalization
        plotMA(MA.l, array=1, main = "After within-array normalization")
        mtext("Dependence of timing ratios on signal intensities", side = 3,
              line = 1, outer = TRUE, cex = 1.5)
        
        dev.off()
      }
      
      if(sortie_image == "Yes"){
        ## BOXPLOT
        filename = paste( prefixe,"/Normalisation/",nom,"_boxplot.pdf", sep ="")
        
        pdf(filename)
        
        par(oma = c(0, 0, 3, 0), mfrow = c(2, 1), mex = 0.7)
        boxplot(MA.l$M~col(MA.l$M), main = "Perform loess normalization",
                border = "dodgerblue4", col = "cornflowerblue")
        boxplot(MA.q$M~col(MA.q$M), main = "Perform scale normalization",
                border = "dodgerblue4", col = "cornflowerblue")
        mtext("Distribution replication timing values", side = 3, line = 1,
              outer = TRUE, cex = 1.5)
        
        dev.off()
      }
      
      #-------------------------------------------------------------------------
      # File of normalisation
      #-------------------------------------------------------------------------
      
      filename = paste(prefixe,"/Normalisation/",nom,"_normalise.txt",sep="")
      write.table(MA.q$M, file = filename, quote=F, row.names=F, sep="\t")
      
      #=========================================================================
      # Position
      #=========================================================================
      
      #-------------------------------------------------------------------------
      # Reading intermediate files
      #-------------------------------------------------------------------------
      
      filename = paste(prefixe,"/Normalisation/",nom,"_normalise.txt",sep="")
      tab5rows = read.table(filename, header = T, nrows = 5)
      classes = sapply(tab5rows, class)
      RT = read.table(filename, header=T, comment.char = "", colClasses=classes)
      
      #-------------------------------------------------------------------------
      # Reading original files
      #-------------------------------------------------------------------------
      filename = paste(nomT,".txt",sep="")
      tab5rows = tab5rows_sauve
      classes = sapply(tab5rows, class)
      a = read.table(filename, header=T, comment.char = "",colClasses=classes,
                     skip = fs1, sep = fsSep)
      
      #-------------------------------------------------------------------------
      # Chromosome selection only
      #-------------------------------------------------------------------------
      
      vect = NULL
      for ( i in 1:dim(a)[1]){
        if (substr(a$SystematicName[i], 1,3) != "chr"){
          vect = c(vect, i)
        }
        progress = (i/dim(a)[1]) * 100
        cat("Progression : ", progress,"%\n")
      }
      if ( is.null(vect) == FALSE){
        RT = RT[-vect,]
        a = a[- vect, ]
      }
      
      x = strsplit(as.character(a$SystematicName), ":")
      xb = strsplit(as.character(a$SystematicName), "-")
      y = unlist(x)
      yb = unlist(xb)
      y1 = y[c(TRUE, FALSE)]
      y2 = yb[c(FALSE,TRUE)]
      
      y3 = y[c(FALSE, TRUE)]
      y3b = strsplit(as.character(y3), "-")
      y3b = unlist(y3b)
      y4 = y3b[c(TRUE, FALSE)]
      y4 = as.numeric(y4)
      y2 = as.numeric(y2)
      
      RT = data.frame(CHR=y1, POSITION=y4, RT, stringsAsFactors=F)
      RT = RT[order(RT$CHR, RT$POSITION),]
      
      RT = na.omit(RT)
      RTS = as.data.frame(RT)
      
      names(RT)[3:4] = c("mLymphR1", "mLymphR2")
      RT$mLymphAve = (RT[,3] + RT[,4])/2
      filename = paste(prefixe,"/File_software/",nom,"_average.txt",sep="")
      write.table(RT,filename, row.names=F, quote=F, sep="\t")
      
      #=========================================================================
      # Autocorrelation
      #=========================================================================
      
      num = substring(nom,1,4)
      if(sortie_image == "Yes"){
        
        filename = paste(prefixe,"/Autocorrelation/autocorrelation_",num,".pdf",
                         sep="")
        pdf(filename)
        par(mfrow=c(3,1))
        acf(RT[,3],lag=1000, main = "Replica 1")$acf[2]
        acf(RT[,4],lag=1000, main = "Replica 2")$acf[2]
        acf(RT$mLymphAve, lag=1000, main = "Average two replica")$acf[2]
        dev.off()
      }
    }
    
    #///////////////////////////////////////////////////////////////////////////
    # Normalisation between experiments
    #///////////////////////////////////////////////////////////////////////////
    
    if (e5 == TRUE){
      #=========================================================================
      # Get data of Experiment 1
      #=========================================================================
      prefixe = "Experience_1"
      nom = "E1_R1.txt"
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      data_a_nor1 = read.table(paste(prefixe,"/File_software/",nom,"_average.txt",
                                     sep=""), header = T)
      
      #=========================================================================
      # Get data of Experiment 2
      #=========================================================================
      prefixe = "Experience_2"
      nom = "E2_R1.txt"
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      data_a_nor2 = read.table(paste(prefixe,"/File_software/",nom,"_average.txt",
                                     sep=""), header = T)
      
      #=========================================================================
      # Normalisation
      #=========================================================================
      
      RTT = as.data.frame(cbind(data_a_nor1$mLymphAve,data_a_nor2$mLymphAve))
      RTTn = data.Normalization(RTT, normalization="column", type=nor3)
      
      data_a_nor1$mLymphAve = RTTn$V1
      data_a_nor2$mLymphAve = RTTn$V2
      
      #=========================================================================
      # Write normalized data of Experiment 1
      #=========================================================================
      
      prefixe = "Experience_1"
      nom = "E1_R1.txt"
      
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      filename = paste(prefixe,"/File_software/",nom,"_average.txt",sep="")
      write.table( data_a_nor1,filename, row.names=F, quote=F, sep="\t")
      
      #=========================================================================
      # Write normalized data of Experiment 2
      #=========================================================================
      prefixe = "Experience_2"
      nom = "E2_R1.txt"
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      filename = paste(prefixe,"/File_software/",nom,"_average.txt",sep="")
      write.table( data_a_nor2,filename, row.names=F, quote=F, sep="\t")
      
    }
    
    #///////////////////////////////////////////////////////////////////////////
    # Smooth - TTR - CTR
    #///////////////////////////////////////////////////////////////////////////
    
    increment = 1
    
    for (z in 1 : tour){
      
      #=========================================================================
      # Analysis of experiments 1 or 2
      #=========================================================================
      
      if ( z == 1){
        prefixe = "Experience_1"
      } else if (z == 2){
        prefixe = "Experience_2"
      }
      
      #=========================================================================
      # Get replica filename
      #=========================================================================
      
      if(increment == 1){
        nom = "E1_R1.txt"
        nom2 = "E1_R2.txt"
      } else{
        nom = "E2_R1.txt"
        nom2 = "E2_R2.txt"
      }
      
      increment = 3
      
      nom = sapply(strsplit(basename(nom),"\\."),
                   function(x) paste(x[1:(length(x)-1)], collapse="."))
      nom2 = sapply(strsplit(basename(nom2),"\\."),
                    function(x) paste(x[1:(length(x)-1)], collapse="."))
      num = substring(nom,1,4)
      RT = read.table(paste(prefixe,"/File_software/",nom,"_average.txt",sep=""),
                      header = T)
      
      #=========================================================================
      # SMOOTH
      #=========================================================================
      
      if (e1 == TRUE){
        # Sort by chromosome then by
        RT = RT[order(RT$CHR, RT$POSITION),]
        RT = na.omit(RT)
        RTS = as.data.frame(RT)
        RTL = as.data.frame(RT$CHR)
        # chrs = levels(RTL[,1])
        # Add factor to avoid empty list
        chrs = levels(factor(RTL[,1]))
        motelim = c("chr11_gl000202_random", "chr17_gl000204_random",
                    "chr17_gl000205_random","chr19_gl000209_random",
                    "chr1_gl000192_random", "chr4_gl000193_random",
                    "chr7_gl000195_random", "chr9_gl000198_random", "chrM")
        
        # Remove random chromosomes
        chrs2 = chrs[!(chrs %in% motelim)]
        
        str(chrs)
        AllLoess = NULL
        RT = na.omit(RT)
        model_loess = NULL
        
        # check table centromere for other
        
        if(organisme == "Other"){
          req(input$file_E1_R1)
          tableauCentroFile = read.csv2(input$inputFileOtherCentro$datapath,sep = "\t", row.names = 1)
          
          # If wrong size
          if(ncol(tableauCentroFile) != 2) {
            tableauCentro = matrix(0, length(chrs2), 2)
            colnames(tableauCentro) = c("debut", "fin")
            rownames(tableauCentro) = chrs2
          } 
          else {
            tableauCentro = matrix(0, length(chrs2), 2)
            colnames(tableauCentro) = c("debut", "fin")
            rownames(tableauCentro) = chrs2
            
            for(n in rownames(tableauCentroFile)){
              tableauCentro[n, 1] = tableauCentroFile[n, 1]
              tableauCentro[n, 2] = tableauCentroFile[n, 2]
            }
            tableauCentro = data.matrix(tableauCentro)
          }
        }
        
        for (chr in chrs2) {
          cat("Current chromosome Lissage: ", chr,"\n")
          if (organisme == "Human"){
            centro = centromere(chr,"hg18")
          }
          else if (organisme == "hg19"){
            centro = centromere(chr,"hg19")
          }
          else if (organisme == "hg38"){
            index.chr <- which(hg38$chrom %in% chr)
            centro <- c(hg38[index.chr, 3], hg38[index.chr, 4])
          }
          else if (organisme == "noCentromere" ){
            centro = no_centro(chr)
          }else {
            centro = centro_Other(tableauCentro, chr)
          }
          
          RTbinter = subset(RT, RT$CHR == chr)
          # Extraction chromosomes
          filename = paste(prefixe,"/Chromosomes/",chr,".txt",sep="")
          write.table(RTbinter, filename, row.names=F,quote=F, sep="\t")
          
          for (j in c(1,2)){
            RTb = subset(RT, RT$CHR == chr)
            if (j == 1){
              ligne = which(RTb$POSITION < centro[j])
            }else{
              ligne = which(RTb$POSITION > centro[j])
            }
            RTb = RTb[ligne, ]
            # if( dim(RTb)[1] != 0){
            if( dim(RTb)[1] > 1){
              RTl = NULL
              if (v4 != "Loess"){
                p_mov = v5
                methodo = v4
                inter = c(RTb$mLymphR1, rep (RTb$mLymphR1[length(RTb$mLymphR1)],
                                             p_mov/2))
                RTla = movavg(inter, p_mov, methodo)
                RTla = RTla[-(1:p_mov/2)]
                
                inter = c(RTb$mLymphR2, rep (RTb$mLymphR2[length(RTb$mLymphR2)],
                                             p_mov/2))
                RTlb =  movavg( inter, p_mov, methodo)
                RTlb = RTlb[-(1:p_mov/2)]
                
                inter = c(RTb$mLymphAve, rep (RTb$mLymphAve[length(RTb$mLymphAve)],
                                              p_mov/2))
                RTlc =  movavg(inter, p_mov, methodo)
                RTlc = RTlc[-(1:p_mov/2)]
                RTl = data.frame(CHR=RTb$CHR,POSITION=RTb$POSITION, RTla,RTlb, RTlc)
                RTl[, (dim(RTl)[2]+1)] = j
                AllLoess = rbind(AllLoess, RTl)
                
              } else {
                lspan = v1/(max(RTb$POSITION)-min(RTb$POSITION))
                RTla = loess(RTb$ mLymphR1~ RTb$POSITION, span = lspan)
                RTlb = loess(RTb$ mLymphR2~ RTb$POSITION, span = lspan)
                RTlc = loess(RTb$mLymphAve ~ RTb$POSITION, span = lspan)
                RTl = data.frame(CHR=RTb$CHR,POSITION=RTb$POSITION,
                                 RTla$fitted,RTlb$fitted, RTlc$fitted)
                RTl[, (dim(RTl)[2]+1)] = j
                AllLoess = rbind(AllLoess, RTl)
              }
            }
          }
          
          RTc = subset(RT, CHR == chr)
          LSc = subset(AllLoess, CHR == chr)
          LSc1 = LSc[which(LSc$V6==1), ]
          LSc2 = LSc[which(LSc$V6==2), ]
          
          #---------------------------------------------------------------------
          # Write Smooth data
          #---------------------------------------------------------------------
          filename = paste(prefixe,"/Chromosomes/Loess_",chr,".txt",sep="")
          write.table(LSc, filename, row.names=F,quote=F, sep="\t")
          
          #---------------------------------------------------------------------
          # Plot preparation
          #---------------------------------------------------------------------
          size = dim(RTc)[2]+1
          
          RTc[RTc$mLymphR1 < 0,size] =  "gray87" #  "green"
          RTc[RTc$mLymphR1 > 0,size] =  "gray87" #  "red"
          
          RTc[RTc$mLymphR2 < 0,size +1] =  "gray87" #  "green"
          RTc[RTc$mLymphR2 > 0,size +1] =  "gray87" #  "red"
          
          RTc[RTc$mLymphAve < 0,size +2] = "gray87" #  "green"
          RTc[RTc$mLymphAve > 0,size +2] = "gray87" #  "red"
          
          names(LSc1)[3:5] = c("x300smo_mLymphR1", "x300smo_mLymphR2",
                               "x300smo_mLymphAve")
          
          names(LSc2)[3:5] = c("x300smo_mLymphR1", "x300smo_mLymphR2",
                               "x300smo_mLymphAve")
          
          #---------------------------------------------------------------------
          # Smooth graphical output
          #---------------------------------------------------------------------
          
          if(sortie_image == "Yes"){
            filename = paste(prefixe,"/Smooth/Smooth_",chr,"_",num,".pdf",sep="")
            pdf(filename)
            
            par(mar=c(2.2,5.1,1,1), mfrow=c(3,1), pch=19, cex=0.5, cex.lab=1.8,
                xaxs="i", oma = c(1, 0, 5, 0), mex = 0.7)
            
            plot(RTc$mLymphR1~RTc$POSITION, ylab="Replica 1", xaxt="n",
                 col=RTc[,size], cex = 0.8)
            lines(LSc1$x300smo_mLymphR1~LSc1$POSITION, col="blue3", lwd=3)
            lines(LSc2$x300smo_mLymphR1~LSc2$POSITION, col="blue3", lwd=3)
            abline(h=0, col="black", lty = "dotted")
            
            plot(RTc$mLymphR2~RTc$POSITION, ylab="Replica 2", xaxt="n",
                 col=RTc[,size + 1], cex = 0.8)
            lines(LSc1$x300smo_mLymphR2~LSc1$POSITION, col="blue3", lwd=3)
            lines(LSc2$x300smo_mLymphR2~LSc2$POSITION, col="blue3", lwd=3)
            abline(h=0, col="black", lty = "dotted")
            
            plot(RTc$mLymphAve~RTc$POSITION, xlab="Coordinate (bp)",ylab="Average",
                 col=RTc[,size + 2], cex = 0.8)
            lines(LSc1$x300smo_mLymphAve~LSc1$POSITION, col="blue3", lwd=3)
            lines(LSc2$x300smo_mLymphAve~LSc2$POSITION, col="blue3", lwd=3)
            abline(h=0, col="black", lty = "dotted")
            mtext(paste("Loess smoothing curves (",chr,")",sep = ""), side = 3,
                  line = 1, outer = TRUE, cex = 1.5)
            
            dev.off()
          }
        }
        
        #-----------------------------------------------------------------------
        # Write all Smooth data
        #-----------------------------------------------------------------------
        x = as.data.frame(AllLoess)
        names(x)[3:5] = c("x300smo_mLymphR1", "x300smo_mLymphR2",
                          "x300smo_mLymphAve")
        filename = paste(prefixe,"/Smooth/",nom,"_Smooth.txt",sep="")
        write.table(x, filename, row.names=F,quote=F, sep="\t")
        
        # Data correlation
        cor(x[,c(3:5)])
      }
      
      #=========================================================================
      # TTR
      #=========================================================================
      
      if (e4 == TRUE){
        Sauvegarde_RT = RT
        tab_coord_TTR = NULL
        tab_seg_glob = NULL
        sum = NULL
        
        chrs2 = chrs2[!chrs2 == "chrY"]
        for (chr in chrs2){
          cat("Current chromosomeTTR: ", chr,"\n")
          
          if (organisme == "Human"){
            centro = centromere(chr,"hg18")
          }
          else if (organisme == "hg19"){
            centro = centromere(chr,"hg19")
          }
          else if (organisme == "hg38"){
            index.chr <- which(hg38$chrom %in% chr)
            centro <- c(hg38[index.chr, 3], hg38[index.chr, 4])
          }
          else if (organisme == "noCentromere" ){
            centro = no_centro(chr)
          }else {
            centro = centro_Other(tableauCentro, chr)
          }
          
          RTbAll = NULL
          PxAll = NULL
          RTseg = NULL
          colorAll = NULL
          diff_annot = 0
          compt_place = 1
          
          start = 1
          end = 0
          numTTR = 0
          vectnumTTR = NULL
          fut_seg = NULL
          fut_TTR = NULL
          
          for (j in 1:2){
            RTb = subset(RT, RT$CHR == chr)
            if (j == 1){
              RTb = RTb[which(RTb$POSITION < centro[j]),]
            }else{
              RTb = RTb[which(RTb$POSITION > centro[j]),]
            }
            # if( dim(RTb)[1] != 0){
            if( dim(RTb)[1] > 1){
              lspan = v1/(max(RTb$POSITION)-min(RTb$POSITION))
              fit = loess(RTb$mLymphAve ~ RTb$POSITION, span = lspan)
              px <- predict(fit, newdata=RTb$POSITION)
              #px1 <- diff(px )
              
              px1 <- px[-1] / px[-length(px)] ############################ / or -
              b = boxplot(px1, plot = F)
              dif = c(which( px1 < b$stats[1,1]), which(px1 > b$stats[5,1]))
              dif = sort(dif)
              
              # Test
              color = rep("white", length(px))
              color[dif] = "gold"
              
              succes = 3
              for (suc in 1:succes){
                recherche = rle(color)
                while (length(which(recherche$lengths <= suc))) {
                  compt = 0
                  for(r in 1:length(recherche$lengths)){
                    compt = compt + recherche$lengths[r]
                    if (recherche$lengths[r] <= suc){
                      if(recherche$values[r] == "gold")
                        color[(compt-suc+1):compt] = "white"
                      else
                        color[(compt-suc+1):compt] = "gold"
                    }
                  }
                  recherche = rle(color)
                }
              }
              
              taille = (dim(RTb)[2]+1)
              RTb[which(color == "white"),taille] = 0 # pas TTR
              RTb[which(color == "gold"), taille] = 1 # TTR
              RTbAll = rbind(RTbAll,RTb)
              PxAll = c(PxAll, px)
              RTseg  = rbind(RTseg, RTb[which(color == "white"),])
              
              recherche = rle(color)
              for( r in 1:length(recherche$lengths)){
                end = end + recherche$lengths[r]
                if(recherche$values[r] == "white"){
                  fut_seg = rbind(fut_seg, c(chr,  start, end))
                }
                if(recherche$values[r] == "gold"){
                  numTTR = numTTR + 1
                  vectnumTTR = c(vectnumTTR, rep(numTTR, recherche$lengths[r]))
                  fut_TTR = rbind(fut_TTR, c(chr,  start, end))
                }
                start = start + recherche$lengths[r]
              }
            }
          }
          
          #=====================================================================
          # CTR
          #=====================================================================
          
          if (e2 == TRUE && is.null(RTbAll) == F){
            print("In seg")
            fut_seg = as.data.frame(fut_seg)
            names(fut_seg) = c("CHR", "loc.start", "loc.end")
            fut_seg[,2] = strtoi(fut_seg[,2]) #str to int
            fut_seg[,3] =  strtoi(fut_seg[,3])
            
            Seg.mLymph = NULL
            for (i in 1: dim(fut_seg)[1]){
              mLymph = CNA(RTbAll$mLymphAve[fut_seg[i,2]:fut_seg[i,3]],
                           RTbAll$CHR[fut_seg[i,2]:fut_seg[i,3]],
                           RTbAll$POSITION[fut_seg[i,2]:fut_seg[i,3]],
                           data.type="logratio", sampleid = "mLymph")
              s = segment(mLymph,  nperm=10000, alpha=1e-15,undo.splits="sdundo",
                          undo.SD= v2, verbose=2)
              Seg.mLymph <- rbind(Seg.mLymph,cbind(s$output$loc.start,
                                                   s$output$seg.mean,
                                                   s$output$loc.end,
                                                   s$output$seg.mean))
            }
            colnames(Seg.mLymph) = c("loc.start","seg.mean","loc.end","seg.mean")
            Seg.mLymph = as.data.frame(Seg.mLymph)
            
            #-------------------------------------------------------------------
            # CTR - Graphical outputs
            #-------------------------------------------------------------------
            
            aff = which(RTbAll[,dim(RTbAll)[2]] == 1)
            col_dif = rep("firebrick3", length(PxAll[-aff]))
            col_dif[which(PxAll[-aff]< 0)] = "forestgreen"
            
            if(sortie_image == "Yes"){
              filename = paste(prefixe,"/Segmentation/seg_",chr,"_",num,".pdf",
                               sep="")
              pdf(filename)
              plot(RTbAll$mLymphAve~RTbAll$POSITION,
                   main = paste("Segmentation in ",chr, sep = ""),
                   xlab="Coordinate (bp)", ylab="mLymph ave", cex = 0.5, pch = 16,
                   col = "gray80")
              segments(Seg.mLymph$loc.start, Seg.mLymph$seg.mean,Seg.mLymph$loc.end,
                       Seg.mLymph$seg.mean, col = "darkblue", lwd = 3)
              legend("topleft", "Early", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "firebrick3",
                     text.font = 2)
              legend("bottomleft", "Late", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "forestgreen",
                     text.font = 2)
              abline(h=0, col="black", lty = "dotted")
              dev.off()
            }
            
          }
          
          #---------------------------------------------------------------------
          # TTR - Graphical outputs
          #---------------------------------------------------------------------
          
          if (e4 == TRUE && is.null(RTbAll) == F){
            
            aff = which(RTbAll[,dim(RTbAll)[2]] == 1)
            col_dif = rep("firebrick3", length(PxAll[-aff]))
            col_dif[which(PxAll[-aff]< 0)] = "forestgreen"
            
            if(sortie_image == "Yes"){
              filename = paste(prefixe,"/TTR/TTR_",chr,"_",num,".pdf",sep="")
              pdf(filename)
              
              plot(RTbAll$mLymphAve~RTbAll$POSITION,
                   main = paste("Timing Transition Region (TTR) in ",chr, sep = ""),
                   xlab="Coordinate (bp)", ylab="mLymph ave", cex = 0.5, pch = 16,
                   col = "gray80")
              points(RTbAll$POSITION[-aff],PxAll[-aff], col = col_dif, pch= 16)
              points(RTbAll$POSITION[aff],PxAll[aff], col = "gold", pch= 16)
              legend("topleft", "Early", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "firebrick3",
                     text.font = 2)
              legend("bottomleft", "Late", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "forestgreen",
                     text.font = 2)
              legend("topright", c("Late","Early","TTR"),
                     cex=0.8, bg = "white",
                     fill = c("forestgreen", "firebrick3" , "gold"),
                     border = c("forestgreen", "firebrick3" , "gold"),
                     title = "Legends", title.adj = 0.5,  bty = "n")
              abline(h=0, col="black", lty = "dotted")
              
              dev.off()
            }
            
          }
          
          #=====================================================================
          # TTR and CTR combinaison
          #=====================================================================
          
          if (e3 == TRUE && is.null(RTbAll) == F){
            if(sortie_image == "Yes"){
              filename = paste(prefixe,"/Fusion/Fusion_",chr,"_",num,".pdf",sep="")
              pdf(filename)
              plot(RTbAll$mLymphAve~RTbAll$POSITION,main =
                     paste("Timing Transition Region (TTR) & segmentation in ",
                           chr, sep = ""),
                   xlab="Coordinate (bp)", ylab="mLymph ave", cex = 0.5, pch = 16,
                   col = "gray80")
              points(RTbAll$POSITION[-aff],PxAll[-aff], col = col_dif, pch= 16)
              points(RTbAll$POSITION[aff],PxAll[aff], col = "gold", pch= 16)
              segments(Seg.mLymph$loc.start, Seg.mLymph$seg.mean,Seg.mLymph$loc.end,
                       Seg.mLymph$seg.mean, col = "darkblue", lwd = 3)
              
              legend("topleft", "Early", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "firebrick3",
                     text.font = 2)
              legend("bottomleft", "Late", horiz = F,
                     cex=1, bg = "white", bty = "n", text.col = "forestgreen",
                     text.font = 2)
              legend("topright", c("Late","Early","TTR"),
                     cex=0.8, bg = "white",
                     fill = c("forestgreen", "firebrick3" , "gold"),
                     border = c("forestgreen", "firebrick3" , "gold"),
                     title = "Legends", title.adj = 0.5,  bty = "n")
              
              abline(h=0, col="black", lty = "dotted")
              dev.off()
            }
            
          }
          
          if (e2 == TRUE){
            #-------------------------------------------------------------------
            # Write segmentation informations
            #-------------------------------------------------------------------
            
            chrom = Seg.mLymph
            filename=paste(prefixe,"/Segmentation/Segmentation_repartition_",
                           chr,"_",num,".pdf",sep="")
            sum1 = c(summary(chrom$seg.mean), nbr = dim(chrom)[1])
            sum = rbind(sum, chr = sum1)
            filename = paste(prefixe,"/Chromosomes/Segmentation_",chr,".txt",sep="")
            write.table (Seg.mLymph, filename , quote=F, row.names=F, sep="\t")
            
            #-------------------------------------------------------------------
            # Graphical output of segmentation
            #-------------------------------------------------------------------
            
            Lymph =  Seg.mLymph
            Lymph$size = Lymph$loc.end - Lymph$loc.start
            LymphEarly = subset(Lymph, Lymph$seg.mean > 0)
            LymphLate = subset(Lymph, Lymph$seg.mean < 0)
            
            if(sortie_image == "Yes"){
              filename=paste(prefixe,"/Segmentation/boxplot",chr,".pdf",sep="")
              pdf(filename)
              boxplot(LymphEarly$size, LymphLate$size, names = c("Early", "Late"),
                      main = "Distribution of early/late domain sizes",
                      border = "dodgerblue4", col = "cornflowerblue", outline = F)
              dev.off()
            }
          }
          
          #---------------------------------------------------------------------
          # Write position of TTR and CTR
          #---------------------------------------------------------------------
          
          if (is.null(RTbAll) == F){
            #...................................................................
            # TTR
            #...................................................................
            
            filename = paste(prefixe,"/Chromosomes/TTR_",chr,".bed",sep="")
            
            tableau_inter_TTR = cbind(RTbAll$POSITION[aff],PxAll[aff], vectnumTTR)
            Final_TTR = NULL
            if(!is.null(tableau_inter_TTR) & nrow(tableau_inter_TTR) != 0){
              for( deroul in 1:max(unique(tableau_inter_TTR[,3]))){
                subset_ttr = tableau_inter_TTR[tableau_inter_TTR[,3] == deroul,]
                Final_TTR = rbind(Final_TTR, c(subset_ttr[1,1],
                                               subset_ttr[nrow(subset_ttr),1]))
              }
            }
            
            write.table (Final_TTR, filename , quote=F, row.names=F,
                         col.names = F, sep="\t")
            filename = paste(prefixe,"/Chromosomes/TTR_all.bed",sep="")

            if(!is.null(Final_TTR)){
              Final_TTR_chr = cbind(rep(chr, nrow(Final_TTR)), Final_TTR)
              write.table (Final_TTR_chr, filename , append=TRUE,quote=F,
                           row.names=F,col.names = F, sep="\t")
            }
            
            filename = paste(prefixe,"/Chromosomes/TTR_",chr,".bed",sep="")
            write.table (cbind(RTbAll$POSITION[aff],PxAll[aff], vectnumTTR),
                         filename , quote=F, row.names=F,col.names = F, sep="\t")
            
            #...................................................................
            # CTR or Not TTR
            #...................................................................
            
            filename = paste(prefixe,"/Chromosomes/NTTR_",chr,".bed",sep="")
            write.table (cbind(RTbAll$POSITION[-aff],PxAll[-aff]), filename ,
                         quote=F, row.names=F, sep="\t")
            filename = paste(prefixe,"/Chromosomes/Segmentation_",chr,".bed",sep="")
            write.table (Seg.mLymph, filename , quote=F, row.names=F, sep="\t")
            
            if(!is.null(RTbAll$POSITION[aff])){
              tab_coord_TTR = rbind(tab_coord_TTR,RTbAll$POSITION[aff])
              tab_seg_glob = rbind(tab_seg_glob,
                                   cbind(CHR = rep(chr, nrow(Seg.mLymph)),Seg.mLymph))
            }
          }
          
          #=====================================================================
          # START-R viewer
          #=====================================================================
          
          #---------------------------------------------------------------------
          # Read Data
          #---------------------------------------------------------------------
          All_data = read.table(paste(prefixe,"/Chromosomes/", chr,".txt",
                                      sep = ""), header = T)
          Loess_data = read.table(paste(prefixe,"/Chromosomes/Loess_", chr,".txt",
                                        sep = ""), header = T)
          Seg_data = read.table(paste(prefixe,"/Chromosomes/Segmentation_", chr,".bed",
                                      sep = ""), header = T)
          if(length(readLines(paste(prefixe,"/Chromosomes/TTR_", chr,".bed",
                                    sep = ""))) != 0){
            TTR_data = read.table(paste(prefixe,"/Chromosomes/TTR_", chr,".bed",
                                        sep = ""), header = F)
          } else {
            TTR_data = matrix(, 0,2)
          }
          
          NTTR_data = read.table(paste(prefixe,"/Chromosomes/NTTR_",chr,".bed",
                                       sep = ""), header = T)
          
          size = dim(All_data)[2]+1
          All_data[All_data$mLymphR1 < 0,size] = "gray87" # "green"
          All_data[All_data$mLymphR1 > 0,size] = "gray87" # "red"
          
          All_data[All_data$mLymphR2 < 0,size +1] = "gray87" # "green"
          All_data[All_data$mLymphR2 > 0,size +1] = "gray87" # "red"
          
          All_data[All_data$mLymphAve < 0,size +2] = "gray87" # "green"
          All_data[All_data$mLymphAve > 0,size +2] = "gray87" # "red"
          
          pos_seg = matrix("NaN",length(Seg_data$loc.start), 3)
          pos_seg[,1] = Seg_data$loc.start
          pos_seg[,2] = Seg_data$loc.end
          pos_seg = as.vector(t(pos_seg))
          
          moyen = matrix("NaN",length(Seg_data$seg.mean), 3)
          moyen[,1] = Seg_data$seg.mean
          moyen[,2] = Seg_data$seg.mean
          moyen = as.vector(t(moyen))
          
          if(nrow(TTR_data) != 0){
            couleur = as.character(TTR_data$V6[!duplicated(TTR_data$V6)])
            TTR = TTR_data[which(TTR_data$V6 == "gold"),]
            names(TTR_data)= c("POSITION","mLymphAve" )
          } else {
            couleur = NULL
            TTR = TTR_data
            colnames(TTR_data)= c("POSITION","mLymphAve" )
          }
          
          names(Loess_data)[3:5] = c("mLymphR1", "mLymphR2","mLymphAve")
          names(NTTR_data) = c("POSITION","mLymphAve" )
          
          NTTR_inf = NTTR_data[which(NTTR_data$mLymphAve < 0), ]
          NTTR_sup = NTTR_data[which(NTTR_data$mLymphAve > 0), ]
          
          Loess_data1 = Loess_data[which(Loess_data[,6] == 1 ), ]
          Loess_data2 = Loess_data[which(Loess_data[,6] == 2 ), ]
          
          Loessm = c( Loess_data1$mLymphAve,"NaN",  Loess_data2$mLymphAve)
          Loessp = c( Loess_data1$POSITION, "NaN",  Loess_data2$POSITION)
          
          Loess_data3 = Loess_data1[which(Loess_data[,6] == 1 ), ]
          Loess_data4 = Loess_data1[which(Loess_data[,6] == 2 ), ]
          Loessm2 = c( Loess_data3$mLymphAve, "NaN",  Loess_data4$mLymphAve)
          Loessp2 = c( Loess_data3$POSITION, "NaN",  Loess_data4$POSITION)
          
          
          # General
          varg = " var trace1 = {
          x:["
          vary  =
            " ] ,y: ["
          vargo  = "],
          mode: 'markers',
          marker: {
          color : 'gray80'
          },
          opacity : 0.2,
          name : 'Data'
        };"
          
          # Loess
          var1 = " var trace2 = {
          x:["
          
          var1o = "],
          mode: 'lines',
          line: {
          color: 'blue',
          width : 2
          },
          name : 'Loess'
      };"
          
          # CRT late
          var2 = " var trace3 = {
          x:["
          
          var2o = "],
          mode: 'markers',
          marker : {
          color: 'green'
          },
          name : 'CTR : Late'
  };"
          
          # CRT early
          var3 = " var trace4 = {
          x:["
          
          var3o = "],
          mode: 'markers',
          marker : {
          color: 'red'
          },
          name : 'CTR : early'
};
          "
          
          # TTR
          var4 = " var trace5 = {
          x:["
          
          var4o = "],
          mode: 'markers',
          marker : {
          color: 'gold'
          },
          name : 'TTR'
};
          "
          
          # seg
          var5 = " var trace6 = {
          x:["
          
          var5o = "],
          mode: 'lines',
          line : {
          color: 'darkmagenta',
          width : 5
          },
          name : 'Segmentation'
  };
          "
          
          data = " var data = [trace1, trace2, trace3, trace4, trace5, trace6];"
          
          layout = paste(" var layout = {
                         title:'Timing replication study for ", chr,"',
                         xaxis: {
                         title: 'Position (pb)'},
                         yaxis: {
                         title: 'Intensity'}
};", sep = "")
          
          # General
          filename = paste(prefixe,"/Viewer/",chr,".js",sep="")
          write( varg, filename)
          write.table( t(All_data$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vary, filename, append = T)
          write.table( t(All_data$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vargo, filename, append = T)
          
          # Loess
          write( var1, filename,  append = T)
          write.table( t(Loessp), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vary, filename, append = T)
          write.table( t(Loessm), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( var1o, filename, append = T)
          
          # CRT late
          write( var2, filename,  append = T)
          write.table( t(NTTR_inf$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vary, filename, append = T)
          write.table( t(NTTR_inf$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( var2o, filename, append = T)
          
          # CRT early
          write( var3, filename, append = T)
          write.table( t(NTTR_sup$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vary, filename, append = T)
          write.table( t(NTTR_sup$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( var3o, filename, append = T)
          
          # TTR
          if(nrow(TTR_data) != 0){
            write( var4, filename, append = T)
            write.table( t(TTR_data$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
            write( vary, filename, append = T)
            write.table( t(TTR_data$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
            write( var4o, filename, append = T)
          }

          # Seg
          write( var5, filename, append = T)
          write.table( t(pos_seg), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( vary, filename, append = T)
          write.table( t(moyen), filename, append = T, sep = ",", col.names = F, row.names = F)
          write( var5o, filename, append = T)
          
          write( data, filename, append = T)
          write( layout, filename, append = T)
          write("Plotly.plot('plot', data, layout); " , filename, append = T)
          
          
          # General - Shiny viewer
          sink(paste0(prefixe,"/Viewer/",chr,".SRV"))
          
          # add important informations
          # norm intre, inter rep, inter exp,
          write.table(cbind(nor1,nor2,nor3,type_dif, organisme, v4, chr),
                      row.names=FALSE,col.names=FALSE,sep="\t", quote = F)

          global_table_viewer = rbind(
            c("Position", "Intensity", "Name"))
          
          if(nrow((cbind(as.numeric(All_data$POSITION), as.numeric(All_data$mLymphAve), "Data"))) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(All_data$POSITION), as.numeric(All_data$mLymphAve), "Data"))
          }
          
          if(nrow((cbind(as.numeric(Loessp), as.numeric(Loessm), "Loess"))) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(Loessp), as.numeric(Loessm), "Loess")                          
            )
          }
          
          if(nrow(NTTR_inf) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(NTTR_inf$POSITION), as.numeric(NTTR_inf$mLymphAve), "CTR : late")                         
            )
          }
          
          if(nrow(NTTR_sup) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(NTTR_sup$POSITION), as.numeric(NTTR_sup$mLymphAve), "CTR : early")                      
            )
          }
          
          if(nrow(TTR_data) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(TTR_data$POSITION), as.numeric(TTR_data$mLymphAve), "TTR")                        
            )
          }
          
          if(length(pos_seg) != 0){
            global_table_viewer = rbind(global_table_viewer,
                                        cbind(as.numeric(pos_seg), as.numeric(moyen), "Segmentation")                        
            )
          }
          
          write.table(global_table_viewer, row.names=FALSE,col.names=FALSE,sep="\t", quote = F)
          
          sink()
          
        }
      }
      
      ##########################################################################
      # Global writing field
      ##########################################################################
      
      tab_coord_TTR = as.data.frame(tab_coord_TTR)
      filename = paste(prefixe,"/TTR/TTR_position_",num,".bed",sep="")
      write.table(tab_coord_TTR,filename, row.names=F, quote=F,col.names = F, sep="\t")
      
      tab_seg_glob = as.data.frame(tab_seg_glob)
      filename = paste(prefixe,"/Chromosomes/Segmentation_all.bed",sep="")
      write.table(tab_seg_glob,filename, row.names=F, quote=F,col.names = F, sep="\t")
      
      rownames(sum) = chrs2
      sum = as.data.frame(sum)
      filename = paste(prefixe,"/Segmentation/",nom,"_resume_segmentation.txt",sep="")
      write.table(sum, file = filename, quote=F, row.names=T, sep="\t")
      
      moyenne = cbind(RT$mLymphAve, moyenne)
      
    }
    
    #///////////////////////////////////////////////////////////////////////////
    # Differential analysis
    #///////////////////////////////////////////////////////////////////////////
    
    
    if (e5 == TRUE){

      dir.create("Differential")
      dir.create("Differential/Viewer")

      if (input$select_method_pvalue == "Automatic pvalue"){
        
        dir.create("Differential/Pvalue")

        ALL_dif = NULL
        tab_pourcentage = NULL
        max_tot = 0
        sum_tot = 0
        tab_coord_dif = NULL
        
        # Test mean method with these p-values
        list.pvalues <- sort(c(seq(1e-1, 1, 0.05), seq(1e-2, 0.095, 0.005), seq(1e-3, 0.0095, 0.0005), 
                               1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-9, 1e-10, 
                               1e-11, 1e-12, 1e-13, 1e-14, 1e-15, 1e-16, 1e-17, 1e-18, 1e-19, 1e-20, 
                               1e-21, 1e-22, 1e-23, 1e-24, 1e-25, 1e-26, 1e-27, 1e-28, 1e-29, 1e-30))
        pvalues <- c()
        nbr.diff.regions <- c()
        per <- c()
        
        for (pv1 in list.pvalues){
          
          ALL_dif = NULL
          tab_pourcentage = NULL
          max_tot = 0
          sum_tot = 0
          tab_coord_dif = NULL
          
          for (chr in chrs2){
            cat(paste("dif :", chr), file = stderr())
            top = 0
            flag = 0
            etat = 0
            #=======================================================================
            # Read data
            #=======================================================================
            
            All_data1 = read.table(paste("Experience_1/Chromosomes/", chr,".txt",
                                         sep = ""), header = T)
            Loess_data1 = read.table(paste("Experience_1/Chromosomes/Loess_", chr,".txt",
                                           sep = ""), header = T)
            Seg_data1 = read.table(paste("Experience_1/Chromosomes/Segmentation_",
                                         chr,".bed", sep = ""), header = T)
            TTR1 = read.table(paste("Experience_1/Chromosomes/TTR_", chr,".bed",
                                    sep = ""), header = F)
            
            All_data2 = read.table(paste("Experience_2/Chromosomes/", chr,".txt",
                                         sep = ""), header = T)
            Loess_data2 = read.table(paste("Experience_2/Chromosomes/Loess_",
                                           chr,".txt", sep = ""), header = T)
            Seg_data2 = read.table(paste("Experience_2/Chromosomes/Segmentation_",
                                         chr,".bed", sep = ""), header = T)
            TTR2 = read.table(paste("Experience_2/Chromosomes/TTR_", chr,".bed",
                                    sep = ""), header = F)
            
            lspan = v1/(max(All_data1$POSITION)-min(All_data1$POSITION))
            
            RTb = cbind(All_data1$CHR, All_data1$POSITION, All_data1$mLymphAve,
                        All_data2$mLymphAve)
            RTb = as.data.frame(RTb)
            colnames(RTb)  = c("CHR","POSITION", "E1", "E2")
            
            if (type_dif == "Mean method"){
              taille_fenetre = pv2
              overlap = pv4
              p_value = pv1
              log_p = 1 - log(p_value)
              
              tab_pval = matrix(0,dim(RTb)[1]/(taille_fenetre-overlap)-2,8)
              colnames(tab_pval) = c("POSITION","pval", "log", "col", "m1", "m2",
                                     "col2", "dif")
              posp = seq(1,dim(RTb)[1], taille_fenetre-overlap)
              
              for (i in 1:floor(dim(RTb)[1]/(taille_fenetre-overlap)-2) ){
                tab_pval[i,1] = as.numeric(as.character( RTb[posp[i], 2])) #+ floor(taille_fenetre/2)
                a = as.numeric(as.character(RTb[posp[i]:(posp[i]+taille_fenetre-1),3]))
                b = as.numeric(as.character(RTb[posp[i]:(posp[i]+taille_fenetre-1),4]))
                
                if(anyNA(a) == TRUE || anyNA(b) == TRUE  ){
                  tab_pval[i,2] = 0
                  tab_pval[i,3] = 0
                  tab_pval[i,5] = 0
                  tab_pval[i,6] = 0
                }else {
                  tab_pval[i,2] = t.test(a,b)$p.value
                  tab_pval[i,3] = 1 - log10(as.numeric(as.character(tab_pval[i,2])))
                  tab_pval[i,5] = mean(a)
                  tab_pval[i,6] = mean(b)
                }
              }
              tab_pval[, 2] =  p.adjust(as.numeric(as.character(tab_pval[,2])), method = pv3)
              
              for (i in 1:floor(dim(RTb)[1]/(taille_fenetre-overlap)-2) ){
                if (as.numeric(as.character(tab_pval[i,3])) < log_p){
                  tab_pval[i,4] = "forestgreen"
                }else if (as.numeric(as.character(tab_pval[i,3])) > log_p){
                  tab_pval[i,4] = "red"
                }
                
                tab_pval[i,8]= as.numeric(as.character(tab_pval[i,5]))-as.numeric(as.character(tab_pval[i,6]))
                
                if (is.na(as.numeric(as.character(tab_pval[i,5])) ) || is.na(as.numeric(as.character(tab_pval[i,5])) )){
                  tab_pval[i,7] = "white"
                  tab_pval[i,8] = 0
                }else if (as.numeric(as.character(tab_pval[i,5])) > as.numeric(as.character(tab_pval[i,6])) && as.numeric(as.character(tab_pval[i,3])) > log_p){
                  tab_pval[i,7] = "blue"
                }else if (as.numeric(as.character(tab_pval[i,5])) < as.numeric(as.character(tab_pval[i,6])) && as.numeric(as.character(tab_pval[i,3])) > log_p ){
                  tab_pval[i,7] = "chocolate"
                }
                
              }
              
              if (organisme == "Human"){
                centro = centromere(chr,"hg18")
              }
              else if (organisme == "hg19"){
                centro = centromere(chr,"hg19")
              }
              else if (organisme == "hg38"){
                index.chr <- which(hg38$chrom %in% chr)
                centro <- c(hg38[index.chr, 3], hg38[index.chr, 4])
              }
              else if (organisme == "noCentromere" ){
                centro = no_centro(chr)
              }else {
                centro = centro_Other(tableauCentro, chr)
              }
              
              pos_centro = centro
              
              tab_centro = rbind(cbind(as.character(chr) ,pos_centro[1]),cbind(as.character(chr),pos_centro[2]))
              tab_centro = as.data.frame(tab_centro)
              tab_centro[,1] = as.character(tab_centro[,1])
              
              if (length(2: (nrow(All_data1)-1)) >=1000){
                pos_sample = sample(2: (nrow(All_data1)-1), 1000)
              } else {
                pos_sample = sample(2: (nrow(All_data1)-1), length(2: (nrow(All_data1)-1)))
              }
              
              
              # Calculation of the average size between 2 positions
              M_sample = NULL
              for(comp_sample in pos_sample){
                M_sample = c(M_sample, mean(c((All_data1$POSITION[comp_sample]- All_data1$POSITION[(comp_sample-1)]),(All_data1$POSITION[(comp_sample+1)] - All_data1$POSITION[(comp_sample)]))))
              }
              moyenne_entre_pos = mean(M_sample)
              
              centro_chrom = subset(tab_centro, tab_centro$V1 == chr)
              mat_centro = matrix(0,dim( centro_chrom)[1],8)
              colnames(mat_centro) = colnames(tab_pval)
              
              mat_centro[,1] = as.numeric(as.character(centro_chrom[,2]))
              mat_centro[,2] = 1
              mat_centro[,3] = 1 - log10(as.numeric(as.character(mat_centro[,2])))
              mat_centro[,4] = "forestgreen"
              mat_centro[,7] = "white"
              
              tab_pval = rbind(tab_pval,mat_centro)
              tab_pval = as.data.frame(tab_pval)
              tab_pval[,1] = as.numeric(as.character(tab_pval[,1]))
              tab_pval = tab_pval[order(tab_pval[,1]),]
              tab_pval = as.matrix(tab_pval)
              
              etat = 0
              compt = 0
              test = NULL
              
              ###
              iteration.pos0.delayed <- 0
              iteration.pos0.advanced <- 0
              ###
              
              for (i in 2 : (dim(tab_pval)[1]-1)){
                
                if (tab_pval[i,4] != "forestgreen"){
                  if (tab_pval[i,7] == "blue"){
                    etat = etat + 2
                    compt = compt +1
                  }else if (tab_pval[i,7] == "chocolate"){
                    etat = etat - 1
                    compt = compt +1
                  } else if (tab_pval[i,7] == "white")
                    etat = etat
                }
                
                if ( tab_pval[i,4] != "forestgreen" & i == (dim(tab_pval)[1]-1)){
                  max = tab_pval[i,"POSITION"]
                  top = 2
                }
                
                if ( tab_pval[i-1,4] != "forestgreen" & i-1 == 1){
                  min = tab_pval[i,"POSITION"]
                  top = 1
                }
                if (tab_pval[i,4] == "forestgreen" & tab_pval[i+1,4] != "forestgreen" & tab_pval[i-1,4] != "forestgreen"){
                  flag = 1
                  min2 = tab_pval[i,"POSITION"]
                  max = tab_pval[i,"POSITION"]
                  
                  # Recover the first value (when iteration.pos = 0)
                  if (iteration.pos0.delayed == 0 && etat == 2 * compt){
                    pos.0.delayed <- as.numeric(min2)
                    iteration.pos0.delayed <- iteration.pos0.delayed + 1
                  }
                  
                  if (iteration.pos0.advanced == 0 && etat == -1 * compt){
                    pos.0.advanced <- as.numeric(min2)
                    iteration.pos0.advanced <- iteration.pos0.advanced + 1
                  }
                  
                  top = top + 1
                  
                }
                
                if( tab_pval[i,4] == "forestgreen" & tab_pval[i-1,4] == "forestgreen" & tab_pval[i+1,4] != "forestgreen" & top != 1){
                  min = tab_pval[i,"POSITION"]
                  top = top +1
                  
                }
                if( tab_pval[i,4] == "forestgreen" & tab_pval[i+1,4] == "forestgreen" & tab_pval[i-1,4] != "forestgreen" & top == 1){
                  max = tab_pval[i,"POSITION"]
                  top = top + 1
                  
                }
                
                if(top == 2){
                  if (flag == 0){
                    if ( etat == 2 * compt){
                      STATE = "DELAYED"
                    } else if (etat == -1 * compt){
                      STATE = "ADVANCED"
                    }else{
                      STATE = "ADVANCED & DELAYED"
                    }
                    tab_coord_dif = rbind(tab_coord_dif, c(CHR = chr,START = min,END = max, STATE = STATE))
                    top = 0
                    compt = 0
                    etat = 0
                    test = c(test, etat)
                  }
                  if (flag == 1){
                    if ( etat == 2 * compt){
                      STATE = "DELAYED"
                    } else if (etat == -1 * compt){
                      STATE = "ADVANCED"
                    }else{
                      STATE = "ADVANCED & DELAYED"
                    }
                    tab_coord_dif = rbind(tab_coord_dif, c(CHR = chr,START = min,END = max, STATE = STATE))
                    min = min2
                    top = 1
                    flag = 0
                    compt = 0
                    etat = 0
                    test = c(test, etat)
                  }
                }
              }
              
              inter = tab_coord_dif[tab_coord_dif[,1]== chr,]
              if (is.vector(inter) == TRUE)
                inter = matrix (inter,1,3)
              debut1 = NULL
              debut2 = NULL
              delayed = NULL
              advanced = NULL
              inter = as.data.frame(inter)
              inter_ad = inter[inter$STATE == "ADVANCED",]
              if (dim(inter_ad)[1] != 0){
                debut1 = as.numeric(as.character(inter_ad[,2]))
                fin1 = as.numeric(as.character(inter_ad[,3]))
              }
              
              
              inter_de = inter[inter$STATE == "DELAYED",]
              if(dim(inter_de)[1] != 0){
                debut2 = as.numeric(as.character(inter_de[,2]))
                fin2 = as.numeric(as.character(inter_de[,3]))
              }
              
              # Vector "debut1" : add the missing position if it exists (for the first value when top < 2)
              if (!is.null(debut1) && is.na(debut1[1])){
                debut1[1] <- pos.0.advanced
              }
              
              if (!is.null(debut1[1])){
                if(debut1[1] == 0){
                  debut1[1] = mean(c(All_data1$POSITION[1], All_data2$POSITION[1]))
                }
              }
              
              # Vector "debut2" : add the missing position if it exists (for the first value when top < 2)
              if (!is.null(debut2) && is.na(debut2[1])){
                debut2[1] <- pos.0.delayed
              }
              
              if (!is.null(debut2[1])){
                if(debut2[1] == 0){
                  debut2[1] = mean(c(All_data1$POSITION[1], All_data2$POSITION[1]))
                }
              }
              
              if(!is.null(debut1)){
                if (organisme == "Human"){
                  # advanced = cbind(debut1, fin1)
                  advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
                } else if (organisme == "noCentromere"){
                  advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
                  # advanced = cbind((debut1 + Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos) ,(fin1+ Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos) )
                  # advanced = cbind((debut1 + (fin1-debut1)/2),(fin1+ (fin1-debut1)/2))
                } else {
                  advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
                }
              }
              if(!is.null(debut2)){
                if (organisme == "Human"){
                  # delayed= cbind(debut2, fin2)
                  delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
                } else if (organisme == "noCentromere"){
                  delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
                  # delayed= cbind((debut2 + Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos), (fin2+ Loess_data1$POSITION[1]- All_data1$POSITION[1] + overlap *  moyenne_entre_pos))
                  # delayed= cbind((debut2 + (fin2-debut2)/2 ), (fin2 + (fin2-debut2)/2))
                } else {
                  delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
                }
              }
              
              if(dim(delayed)[1] == 0 && !is.null(delayed))
                delayed = rbind(delayed, c(NA,NA))
              if(dim(advanced)[1] == 0 && !is.null(advanced))
                advanced = rbind(delayed, c(NA,NA))
            }
            
            if(is.null(advanced) == F){
              advanced = as.data.frame(cbind(rep(chr, dim(advanced)[1]), advanced, rep("ADVANCED", dim(advanced)[1])))
              names(advanced) = c("CHR","START", "END", "STATUS")
            }
            if(is.null(delayed) == F){
              delayed = as.data.frame(cbind(rep(chr, dim(delayed)[1]), delayed, rep("DELAYED", dim(delayed)[1])))
              names(delayed) = c("CHR","START", "END", "STATUS")
            }
            
            ALL_dif = rbind(ALL_dif, advanced)
            ALL_dif = rbind(ALL_dif, delayed)
            
            max = max(as.numeric(as.character(RTb$POSITION)))
            dif = c(as.numeric(as.character(advanced[,3])) - as.numeric(as.character(advanced[,2])),
                    as.numeric(as.character(delayed[,3])) - as.numeric(as.character(delayed[,2])))
            sum = sum(dif)
            max_tot = max_tot + max
            sum_tot = sum_tot + sum

          }
          pourcentage_tot = sum_tot * 100 / max_tot
          per <- c(per, pourcentage_tot)
          print(pv1)
          nbr <- dim(ALL_dif)[1]
          if (is.null(dim(ALL_dif)[1])){
            nbr <- 0
          }
          print(nbr)
          nbr.diff.regions <- c(nbr.diff.regions, nbr)
          pvalues <- c(pvalues, pv1)
        }
        
        df.comparison.pvalue <- data.frame(PValue = pvalues, Nbr_region = nbr.diff.regions, Percentage = per)
        write.table(df.comparison.pvalue, "Differential/Pvalue/table_results_per_pvalue.txt", sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)
        
        # # Remove the (n - 1) lines associated with 0 when n lines contain the value 0
        # ind.0 <- which(df.comparison.pvalue$Percentage %in% 0)
        # # Find the maximum value to stop the representation of the curve at this value
        # ind.max.df <- which.max(df.comparison.pvalue$Percentage)
        # if (length(ind.0) > 0){
        #   df <- df.comparison.pvalue[-c(ind.0[1 : (length(ind.0) - 1)], seq((ind.max.df + 1), dim(df.comparison.pvalue)[1], 1)), ]
        # }
        # if (length(ind.0) == 0 && ind.max.df < dim(df.comparison.pvalue)[1]){
        #   df <- df.comparison.pvalue[-seq((ind.max.df + 1), dim(df.comparison.pvalue)[1], 1), ]
        # }
        # if (length(ind.0) == 0 && ind.max.df == dim(df.comparison.pvalue)[1]){
        #   df <- df.comparison.pvalue
        # }
        
        ind.0 <- which(df.comparison.pvalue$Percentage %in% 0)
        # Check if we have replicates (if few p-values are associated to a number > 0)
        if (length(ind.0) > 80){
          df <- df.comparison.pvalue[-ind.0, ]
          pv1 <- df[which.min(df.comparison.pvalue$PValue), "PValue"]
        }
        if (length(ind.0) < 80){
          if (length(ind.0) > 0){
            df <- df.comparison.pvalue[-ind.0, ]
          }
          # Find the maximum value to stop the representation of the curve at this value
          ind.max.df <- which.max(df.comparison.pvalue$Percentage)
          if (ind.max.df < dim(df.comparison.pvalue)[1]){
            df <- df.comparison.pvalue[-seq((ind.max.df + 1), dim(df.comparison.pvalue)[1], 1), ]
          }
        }
              
        write.table(df, "Differential/Pvalue/table_results_per_pvalue_removed-values.txt", sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)
        
        if (input$select_method_automatic == "Euclidean distance" && length(ind.0) < 80){
          
          df <- df[, c("PValue", "Percentage")]
          df <- df[order(df$PValue), ]
          df$PValue <- -log10(df$PValue)
          
          df <- remove.small.var(df, value = 5e-3)
          # Recover values from dataframe
          x <- df$PValue
          y <- df$Percentage
          
          # Smoothing of the curve representing the number as a function of the p-value
          smooth.loess <- loess(y ~ x, span = 0.5)
          
          # Study the curve between the first value and the value associated to the highest y (ordinate)
          ind.max.fitted <- which.max(smooth.loess$fitted)
          x.after.max <- x[1:ind.max.fitted]
          y.after.max <- y[1:ind.max.fitted]
          fitted <- smooth.loess$fitted[1:ind.max.fitted]
          # Directing coefficient of the line connecting the extremities of the curve
          a <- (fitted[1] - fitted[length(fitted)]) / (x.after.max[1] - x.after.max[length(x.after.max)])
          # Ordinate at the origin of the line
          b <- fitted[1] - a * x.after.max[1]
          
          # Directing coefficient of the perpendicular line
          a.perp <- -1 / a
          # Ordinate at the origin of the perpendicular line for each x
          x.smooth <- seq(x.after.max[length(x.after.max)], x.after.max[1], 0.001)
          y.smooth <- predict(smooth.loess, x.smooth)
          b.perp <- y.smooth - a.perp * x.smooth
          
          # Coordinates of the intersection points between the perpendicular lines and the segment
          x.perp <- (b.perp - b) / (a - a.perp)
          y.perp <- a * x.perp + b
          
          # Vector containing the distances between each point on the curve and the segment
          dist.list <- dist.euclid(x.perp, x.smooth, y.perp, y.smooth)
          
          # Value of the maximum distance between the curve and the line
          ind.max <- which.max(dist.list)
          # Value : -log10(p-value)
          pval <- 10**-x.smooth[ind.max]
          pv1 <- pval
          
          pdf("Differential/Pvalue/Detect_the_furthest_point.pdf")
          
          # The curve representing the number as a function of the p-value
          plot(x, y, xlab = "-log10(p-value)", ylab = "Percentage of different regions")
          title(main = "Detect the furthest point of the line")
          # Smoothing of the curve
          lines(smooth.loess$fitted ~ smooth.loess$x, col = "blue3", lwd = 3)
          lines(x, a * x + b, col = "green")
          # Line perpendicular to the segment and passing through the furthest point of the segment
          lines(x.smooth, (a.perp * x.smooth + b.perp[ind.max]), col = "blue")
          # Intersection between the p-value curve and the line perpendicular to the segment
          points(x.smooth[ind.max], y.smooth[ind.max], pch = 19, col = 'red')
          # Intersection between the perpendicular line and the segment
          points(x.perp[ind.max], y.perp[ind.max], pch = 19, col = 'red')
          # Value of the p-value corresponding to the maximum distance between the curve and the segment
          abline(v = x.smooth[ind.max], col = "red")
          
          dev.off()
        }
          
        if (input$select_method_automatic == "Bezier curve" && length(ind.0) < 80){
          
          df <- df[, c("PValue", "Percentage")]
          df <- df[order(df$PValue), ]
          df$PValue <- -log10(df$PValue)
          
          df <- remove.small.var(df, value = 5e-3)
          # Recover values from dataframe
          x <- df$PValue
          y <- df$Percentage
          
          smooth.loess <- loess(y ~ x, span = 0.5)
          
          # If smoothing changes the profile then the maximum value is changed
          # Check whether all values are positive
          # Negative values indicate a profile changing
          # Tolerance threshold : [-0.5 - 0]
          ind.diff <- which(diff(smooth.loess$fitted) < -0.5)
          if (length(ind.diff) <= 1){
            ind.begin <- length(x)
          }
          if (length(ind.diff) > 1){
            # Keep the indices if they are smallest than the middle position
            # The goal is to avoid removing a large part of data
            ind.diff <- ind.diff[ind.diff > 0.5 * length(x)]
            if (length(ind.diff) > 0){
              ind.begin <- min(ind.diff)
            }
            if (length(ind.diff) == 0){
              ind.begin <- length(x)
            }
          }
          
          # Update usable values
          x <- x[1:ind.begin]
          y <- y[1:ind.begin]
          
          smooth.loess <- loess(y ~ x, span = 0.5)
          
          # Find the intersection of tangents
          # Tangent 1 equation
          a.t1 <- (smooth.loess$fitted[1] - smooth.loess$fitted[3]) / (smooth.loess$x[1] - smooth.loess$x[3])
          b.t1 <- smooth.loess$fitted[2] - a.t1 * smooth.loess$x[2]
          # Tangent 2 equation
          ind.t2 <- length(smooth.loess$x)
          a.t2 <- (smooth.loess$fitted[ind.t2] - smooth.loess$fitted[ind.t2 - 2]) / (smooth.loess$x[ind.t2] - smooth.loess$x[ind.t2 - 2])
          b.t2 <- smooth.loess$fitted[ind.t2 - 1] - a.t2 * smooth.loess$x[ind.t2 - 1]
          # Abscissa and ordinate of intersection point
          x.inter <- (b.t2 - b.t1) / (a.t1 - a.t2)
          y.inter <- a.t1 * x.inter + b.t1
          
          # Middle of tangents
          # Tangent 1
          x.tangent1 <- smooth.loess$x[2]
          x.middle1 <- ( x.inter + x.tangent1 ) / 2
          y.middle1 <- ( y.inter + (a.t1 * x.tangent1 + b.t1) ) / 2
          # Tangent 2
          x.tangent2 <- smooth.loess$x[ind.t2 - 1]
          x.middle2 <- ( x.inter + x.tangent2 ) / 2
          y.middle2 <- ( y.inter + (a.t2 * x.tangent2 + b.t2) ) / 2
          
          # Middle of line binding the middle of each tangent
          x.middle <- ( x.middle1 + x.middle2 ) / 2
          y.middle <- ( y.middle1 + y.middle2 ) / 2
          
          # Line binding the middle of each tangent
          a.middles <- (y.middle1 - y.middle2) / (x.middle1 - x.middle2)
          b.middles <- y.middle1 - a.middles * x.middle1
          
          # Line connecting intersection of tangents and the last middle point
          a.final <- (y.middle - y.inter) / (x.middle - x.inter)
          b.final <- y.middle - a.final * x.middle
          
          # Find intersection between the last line and the curve
          # Increase the precision of detection thanks to the using of more points
          x.interval <- seq(x[length(x)], x[1], 0.001)
          y.interval <- predict(smooth.loess, x.interval)
          dist <- dist.euclid(x.interval, x.interval, (a.final * x.interval + b.final), y.interval)
          ind.pval <- which.min(dist)
          pval <- x.interval[ind.pval]
          pv1 <- 10**-pval
          
          # Return results
          y.tangent1 <- a.t1 * x.interval + b.t1
          y.tangent2 <- a.t2 * x.interval + b.t2
          
          predictions1 <- list(smooth.loess$x[2], smooth.loess$fitted[2])
          predictions2 <- list(smooth.loess$x[ind.t2 - 1], smooth.loess$fitted[ind.t2 - 1])
          
          pdf("Differential/Pvalue/Bezier-curve_pvalue-detection.pdf")
          
          # The curve representing the number as a function of the p-value
          plot(x, y, main = "Automatic detection of p-value : Bezier curve", xlab = "-log10(p-value)", ylab = "Percentage of different regions")
          # Smoothing of the curve
          # lines(spl, col = "blue3", lwd = 3)
          lines(smooth.loess$fitted ~ smooth.loess$x, col = "blue3", lwd = 3)
          # Point from which the tangent 1 is constructed
          points(predictions1[1], predictions1[2], col = 2, pch = 19)
          # Line of tangent 1
          lines(x.interval, y.tangent1, col = 3)
          # Point from which the tangent 2 is constructed
          points(predictions2[1], predictions2[2], col = 2, pch = 19)
          # Line of tangent 2
          lines(x.interval, y.tangent2, col = 3)
          # Point of intersection between the two tangents
          points(x.inter, y.inter, col = 2, pch = 19)
          # Point in the middle of the tangent 1
          points(x.middle1, y.middle1, col = 3, pch = 19)
          # Point in the middle of the tangent 2
          points(x.middle2, y.middle2, col = 3, pch = 19)
          # Line passing through the two previous middles
          lines(x, (a.middles * x + b.middles), col = 3)
          # Point located in the middle of the segment passing through the two previous middles
          points(x.middle, y.middle, col = 3, pch = 19)
          # Line connecting the last midpoint to the point of intersection of the tangents
          lines(x, (a.final * x + b.final), col = 3)
          # p-value point
          abline(v = pval, col = "red")
          # points(pval, predict(spl, pval)$y, col = "red", pch = 19)
          points(pval, predict(smooth.loess, pval), col = "red", pch = 19)
          
          dev.off()
        }
      }

      # Initialise the variables to perform the analysis with the chosen p-value
      ALL_dif = NULL
      tab_pourcentage = NULL
      max_tot = 0
      sum_tot = 0
      tab_coord_dif = NULL

      
      for (chr in chrs2){
        cat(paste("dif :", chr), file = stderr())
        top = 0
        flag = 0
        etat = 0
        #=======================================================================
        # Read data
        #=======================================================================
        
        All_data1 = read.table(paste("Experience_1/Chromosomes/", chr,".txt",
                                     sep = ""), header = T)
        Loess_data1 = read.table(paste("Experience_1/Chromosomes/Loess_", chr,".txt",
                                       sep = ""), header = T)
        Seg_data1 = read.table(paste("Experience_1/Chromosomes/Segmentation_",
                                     chr,".bed", sep = ""), header = T)
        TTR1 = read.table(paste("Experience_1/Chromosomes/TTR_", chr,".bed",
                                sep = ""), header = F)
        
        All_data2 = read.table(paste("Experience_2/Chromosomes/", chr,".txt",
                                     sep = ""), header = T)
        Loess_data2 = read.table(paste("Experience_2/Chromosomes/Loess_",
                                       chr,".txt", sep = ""), header = T)
        Seg_data2 = read.table(paste("Experience_2/Chromosomes/Segmentation_",
                                     chr,".bed", sep = ""), header = T)
        TTR2 = read.table(paste("Experience_2/Chromosomes/TTR_", chr,".bed",
                                sep = ""), header = F)
        
        lspan = v1/(max(All_data1$POSITION)-min(All_data1$POSITION))
        
        RTb = cbind(All_data1$CHR, All_data1$POSITION, All_data1$mLymphAve,
                    All_data2$mLymphAve)
        RTb = as.data.frame(RTb)
        colnames(RTb)  = c("CHR","POSITION", "E1", "E2")
        
        #=======================================================================
        # Segment method
        #=======================================================================
        
        if(type_dif == "Segment method"){
          #---------------------------------------------------------------------
          # Common TTR
          #---------------------------------------------------------------------
          newTTR1 = NULL
          for (i in 1:TTR1[dim(TTR1)[1],3]){
            inter = TTR1[which(TTR1[,3]==i),]
            newTTR1 = rbind( newTTR1, c(loc.start= inter[1,1],
                                        loc.end = inter[dim(inter)[1],1],
                                        num = i , mean = mean(inter[,2])))
          }
          
          newTTR2 = NULL
          for (i in 1:TTR2[dim(TTR2)[1],3]){
            inter = TTR2[which(TTR2[,3]==i),]
            newTTR2 = rbind( newTTR2, c(loc.start= inter[1,1],
                                        loc.end = inter[dim(inter)[1],1],
                                        num = i , mean = mean(inter[,2])))
          }
          
          df1 = as.data.frame(newTTR1)
          df2 = as.data.frame(newTTR2)
          
          setDT(df1)  ## convert loc.end data.table without copy
          setDT(df2)
          
          setkey(df2, loc.start, loc.end)
          ans = foverlaps(df1, df2, type="any")
          ans = ans[, `:=`(loc.start = pmax(loc.start, i.loc.start),
                           loc.end = pmin(loc.end, i.loc.end))]
          ans = ans[, `:=`(i.loc.start=NULL, i.loc.end=NULL)][loc.start <= loc.end]
          
          pascommunTTR2 = newTTR2[-ans$num,]
          pascommunTTR1 = newTTR1[-ans$i.num,]
          
          if(!is.null(pascommunTTR2) && !is.na(pascommunTTR2) && length(as.numeric(dim(pascommunTTR2))) != 0){
            etude = rep("ADVANCED", dim(pascommunTTR2)[1])
            for (i in 1:dim(pascommunTTR2)[1]) {
              mo = mean(All_data1[which(All_data1$POSITION == pascommunTTR2[i,1]),5],
                        All_data1[which(All_data1$POSITION == pascommunTTR2[i,2]),5])
              if((pascommunTTR2[i,4]- mo) < 0 ){
                etude[i] = "DELAYED"
              }
            }
            pascommunTTR2[,3] = etude
          }
          
          
          if(!is.null(pascommunTTR1) && !is.na(pascommunTTR1) && length(as.numeric(dim(pascommunTTR1))) != 0 ){
            etude = rep("ADVANCED", dim(pascommunTTR1)[1])
            for (i in 1:dim(pascommunTTR1)[1]) {
              mo = mean(All_data2[which(All_data2$POSITION == pascommunTTR1[i,1]),5],
                        All_data2[which(All_data2$POSITION == pascommunTTR1[i,2]),5])
              if((pascommunTTR1[i,4]- mo) > 0){
                etude[i] = "DELAYED"
              }
            }
            pascommunTTR1[,3] = etude
          }
          
          pentedif = NULL
          for(i in 1:dim(ans)[1]){
            if(length(TTR1[which(TTR1[,3]==ans$i.num[i]),2]) != 0 && length(TTR2[which(TTR2[,3]==ans$num[i]),2]) ){
              test1b = lm(TTR1[which(TTR1[,3]==ans$i.num[i]),2] ~ TTR1[which(TTR1[,3]==ans$i.num[i]),1] )
              test2b = lm(TTR2[which(TTR2[,3]==ans$num[i]),2] ~ TTR2[which(TTR2[,3]==ans$num[i]),1] )
              ano = anova(test1b,test2b)
              if(is.nan(ano$Pr[1]) == F && ano$Pr[1] > 0.05){
                pentedif = rbind(pentedif, ans[i,])
              }
            }
            
          }
          
          pentedif2 = NULL
          vec = unique(pentedif$i.num)
          for (v in vec){
            pentedif2 = rbind( pentedif2, newTTR1[which(newTTR1[,3] == v),1:2])
          }
          
          vec = unique(pentedif$num)
          for (v in vec){
            pentedif2 = rbind( pentedif2, newTTR2[which(newTTR2[,3] == v),1:2])
          }
          
          pentedif2 = as.data.frame(pentedif2)
          
          etude = rep("ADVANCED",dim(pentedif2)[1])
          for(i in 1:dim(pentedif2)[1]){
            if( length(All_data1[which(All_data1$POSITION == pentedif2[i,1]),5]) != 0){
              mo1 = mean(All_data1[which(All_data1$POSITION == pentedif2[i,1]),5],All_data1[which(All_data1$POSITION == pentedif2[i,2]),5])
              mo2 = mean(All_data2[which(All_data2$POSITION == pentedif2[i,1]),5],All_data2[which(All_data2$POSITION == pentedif2[i,2]),5])
              if(mo1-mo2 >0)
                etude[i]= "DELAYED"
            }
          }
          
          pentedif2 = as.data.frame(cbind(pentedif2, etude))
          
          df1 = Seg_data1
          df2 = Seg_data2
          
          setDT(df1)  ## convert loc.end data.table without copy
          setDT(df2)
          
          setkey(df2, loc.start, loc.end)
          ans = foverlaps(df1, df2, type="any")
          ans = ans[, `:=`(loc.start = pmax(loc.start, i.loc.start), loc.end = pmin(loc.end, i.loc.end))]
          ans = ans[, `:=`(i.loc.start=NULL, i.loc.end=NULL)][loc.start <= loc.end]
          
          ecart = abs(ans$seg.mean - ans$i.seg.mean)
          ecart2 = ans$i.seg.mean -ans$seg.mean
          
          #---------------------------------------------------------------------
          # Sample
          #---------------------------------------------------------------------
          pos_ecart = NULL
          N = 10000
          
          for (k in 1:dim(ans)[1]){
            ks1 = All_data1$mLymphAve[which(All_data1$POSITION == ans$loc.start[k]):which(All_data1$POSITION == ans$loc.end[k])]
            ks2 = All_data2$mLymphAve[which(All_data2$POSITION == ans$loc.start[k]):which(All_data2$POSITION == ans$loc.end[k])]
            
            ks = c(ks1,ks2)
            ecart_true = abs(ans$seg.mean[k] - ans$i.seg.mean[k] )
            
            if (factorial(length(ks)) > N || factorial(length(ks)) == Inf ){
              ecart = rep(NA, N)
              for (s in 1:N) {
                kss = sample(ks)
                ecart[s] = abs(mean(kss[1:(length(kss)/2)]) - mean(kss[(length(kss)/2 +1 ):length(kss)] ))
              }
              pvalue = length(which(ecart > ecart_true))/ N
            }else{
              p = perms(ks)
              ecart = rep(NA,dim(p)[1])
              for (s in 1:dim(p)[1]) {
                ecart[s] = abs(mean(p[s, 1:(dim(p)[2]/2)]) - mean(p[s,(dim(p)[2]/2 +1 ):dim(p)[2]]))
              }
              pvalue = length(which(ecart > ecart_true))/ dim(p)[1]
            }
            
            if (pvalue < 0.05){
              pos_ecart= c(pos_ecart, k)
            }
          }
          
          newseg = as.data.frame(cbind(ans$loc.start[pos_ecart], ans$loc.end[pos_ecart],  ecart2[pos_ecart]))
          
          if( dim(newseg)[1] != 0){
            etude = rep("ADVANCED", length(ecart2[pos_ecart]))
            etude[which( newseg[,3] > 0)] = "DELAYED"
            newseg[,3]  = etude
          }
          
          
          if( dim(pentedif2)[1] == 0) pentedif2 = matrix(NA,1,4)
          if( dim(newseg)[1] == 0) newseg = matrix(NA,1,4)
          if( is.null(pascommunTTR1) || is.na(pascommunTTR1) || length(as.numeric(dim(pascommunTTR1))) == 0 || dim(pascommunTTR1)[1] == 0) pascommunTTR1 = matrix(NA,1,4)
          if( is.null(pascommunTTR2) || is.na(pascommunTTR2) || length(as.numeric(dim(pascommunTTR2))) == 0 || dim(pascommunTTR2)[1] == 0) pascommunTTR2 = matrix(NA,1,4)
          
          advanced = rbind(cbind(newseg[which(newseg[,3] == "ADVANCED"),1], newseg[which(newseg[,3] == "ADVANCED"),2]),
                           cbind(pascommunTTR1[which(pascommunTTR1[,3] == "ADVANCED"),1],pascommunTTR1[which(pascommunTTR1[,3] == "ADVANCED"),2]),
                           cbind(pascommunTTR2[which(pascommunTTR2[,3]== "ADVANCED"),1],pascommunTTR2[which(pascommunTTR2[,3]== "ADVANCED"),2]),
                           cbind(pentedif2[which(pentedif2[,3] == "ADVANCED"),1], pentedif2[which(pentedif2[,3] == "ADVANCED"),2])
          )
          advanced = as.data.frame(advanced)
          advanced = na.omit(advanced)
          advanced[,1] = as.numeric(as.character(advanced[,1]))
          advanced[,2] = as.numeric(as.character(advanced[,2]))
          
          
          delayed = rbind(cbind(newseg[which(newseg[,3] != "ADVANCED"),1], newseg[which(newseg[,3] != "ADVANCED"),2]),
                          cbind(pascommunTTR1[which(pascommunTTR1[,3] != "ADVANCED"),1],pascommunTTR1[which(pascommunTTR1[,3] != "ADVANCED"),2]),
                          cbind(pascommunTTR2[which(pascommunTTR2[,3]!= "ADVANCED"),1],pascommunTTR2[which(pascommunTTR2[,3]!= "ADVANCED"),2]),
                          cbind(pentedif2[which(pentedif2[,3] != "ADVANCED"),1], pentedif2[which(pentedif2[,3] != "ADVANCED"),2])
          )
          
          delayed = as.data.frame(delayed)
          delayed = na.omit(delayed)
          delayed[,1] = as.numeric(as.character(delayed[,1]))
          delayed[,2] = as.numeric(as.character(delayed[,2]))
          
          #=====================================================================
          # Mean method
          #=====================================================================
          
        }else if (type_dif == "Mean method"){
          taille_fenetre = pv2
          overlap = pv4
          p_value = pv1
          log_p = 1 - log(p_value)
          
          tab_pval = matrix(0,dim(RTb)[1]/(taille_fenetre-overlap)-2,8)
          colnames(tab_pval) = c("POSITION","pval", "log", "col", "m1", "m2",
                                 "col2", "dif")
          posp = seq(1,dim(RTb)[1], taille_fenetre-overlap)
          
          for (i in 1:floor(dim(RTb)[1]/(taille_fenetre-overlap)-2) ){
            tab_pval[i,1] = as.numeric(as.character( RTb[posp[i], 2])) #+ floor(taille_fenetre/2)
            a = as.numeric(as.character(RTb[posp[i]:(posp[i]+taille_fenetre-1),3]))
            b = as.numeric(as.character(RTb[posp[i]:(posp[i]+taille_fenetre-1),4]))
            
            if(anyNA(a) == TRUE || anyNA(b) == TRUE  ){
              tab_pval[i,2] = 0
              tab_pval[i,3] = 0
              tab_pval[i,5] = 0
              tab_pval[i,6] = 0
            }else {
              tab_pval[i,2] = t.test(a,b)$p.value
              tab_pval[i,3] = 1 - log10(as.numeric(as.character(tab_pval[i,2])))
              tab_pval[i,5] = mean(a)
              tab_pval[i,6] = mean(b)
            }
          }
          tab_pval[, 2] =  p.adjust(as.numeric(as.character(tab_pval[,2])), method = pv3)
          
          for (i in 1:floor(dim(RTb)[1]/(taille_fenetre-overlap)-2) ){
            if (as.numeric(as.character(tab_pval[i,3])) < log_p){
              tab_pval[i,4] = "forestgreen"
            }else if (as.numeric(as.character(tab_pval[i,3])) > log_p){
              tab_pval[i,4] = "red"
            }
            
            tab_pval[i,8]= as.numeric(as.character(tab_pval[i,5]))-as.numeric(as.character(tab_pval[i,6]))
            
            if (is.na(as.numeric(as.character(tab_pval[i,5])) ) || is.na(as.numeric(as.character(tab_pval[i,5])) )){
              tab_pval[i,7] = "white"
              tab_pval[i,8] = 0
            }else if (as.numeric(as.character(tab_pval[i,5])) > as.numeric(as.character(tab_pval[i,6])) && as.numeric(as.character(tab_pval[i,3])) > log_p){
              tab_pval[i,7] = "blue"
            }else if (as.numeric(as.character(tab_pval[i,5])) < as.numeric(as.character(tab_pval[i,6])) && as.numeric(as.character(tab_pval[i,3])) > log_p ){
              tab_pval[i,7] = "chocolate"
            }
            
          }
          
          if (organisme == "Human"){
            centro = centromere(chr,"hg18")
          }
          else if (organisme == "hg19"){
            centro = centromere(chr,"hg19")
          }
          else if (organisme == "hg38"){
            index.chr <- which(hg38$chrom %in% chr)
            centro <- c(hg38[index.chr, 3], hg38[index.chr, 4])
          }
          else if (organisme == "noCentromere" ){
            centro = no_centro(chr)
          }else {
            centro = centro_Other(tableauCentro, chr)
          }
          
          pos_centro = centro
          
          tab_centro = rbind(cbind(as.character(chr) ,pos_centro[1]),cbind(as.character(chr),pos_centro[2]))
          tab_centro = as.data.frame(tab_centro)
          tab_centro[,1] = as.character(tab_centro[,1])
          
          if (length(2: (nrow(All_data1)-1)) >=1000){
            pos_sample = sample(2: (nrow(All_data1)-1), 1000)
          } else {
            pos_sample = sample(2: (nrow(All_data1)-1), length(2: (nrow(All_data1)-1)))
          }
          
          
          # Calculation of the average size between 2 positions
          M_sample = NULL
          for(comp_sample in pos_sample){
            M_sample = c(M_sample, mean(c((All_data1$POSITION[comp_sample]- All_data1$POSITION[(comp_sample-1)]),(All_data1$POSITION[(comp_sample+1)] - All_data1$POSITION[(comp_sample)]))))
          }
          moyenne_entre_pos = mean(M_sample)
          
          centro_chrom = subset(tab_centro, tab_centro$V1 == chr)
          mat_centro = matrix(0,dim( centro_chrom)[1],8)
          colnames(mat_centro) = colnames(tab_pval)
          
          mat_centro[,1] = as.numeric(as.character(centro_chrom[,2]))
          mat_centro[,2] = 1
          mat_centro[,3] = 1 - log10(as.numeric(as.character(mat_centro[,2])))
          mat_centro[,4] = "forestgreen"
          mat_centro[,7] = "white"
          
          tab_pval = rbind(tab_pval,mat_centro)
          tab_pval = as.data.frame(tab_pval)
          tab_pval[,1] = as.numeric(as.character(tab_pval[,1]))
          tab_pval = tab_pval[order(tab_pval[,1]),]
          tab_pval = as.matrix(tab_pval)
          
          etat = 0
          compt = 0
          test = NULL

          ###
          iteration.pos0.delayed <- 0
          iteration.pos0.advanced <- 0
          ###

          for (i in 2 : (dim(tab_pval)[1]-1)){
            
            if (tab_pval[i,4] != "forestgreen"){
              if (tab_pval[i,7] == "blue"){
                etat = etat + 2
                compt = compt +1
              }else if (tab_pval[i,7] == "chocolate"){
                etat = etat - 1
                compt = compt +1
              } else if (tab_pval[i,7] == "white")
                etat = etat
            }
            
            if ( tab_pval[i,4] != "forestgreen" & i == (dim(tab_pval)[1]-1)){
              max = tab_pval[i,"POSITION"]
              top = 2
            }
            
            if ( tab_pval[i-1,4] != "forestgreen" & i-1 == 1){
              min = tab_pval[i,"POSITION"]
              top = 1
            }
            if (tab_pval[i,4] == "forestgreen" & tab_pval[i+1,4] != "forestgreen" & tab_pval[i-1,4] != "forestgreen"){
              flag = 1
              min2 = tab_pval[i,"POSITION"]
              max = tab_pval[i,"POSITION"]

              # Recover the first value (when iteration.pos = 0)
              if (iteration.pos0.delayed == 0 && etat == 2 * compt){
                pos.0.delayed <- as.numeric(min2)
                iteration.pos0.delayed <- iteration.pos0.delayed + 1
              }
              
              if (iteration.pos0.advanced == 0 && etat == -1 * compt){
                pos.0.advanced <- as.numeric(min2)
                iteration.pos0.advanced <- iteration.pos0.advanced + 1
              }

              top = top + 1
              
            }
            
            if( tab_pval[i,4] == "forestgreen" & tab_pval[i-1,4] == "forestgreen" & tab_pval[i+1,4] != "forestgreen" & top != 1){
              min = tab_pval[i,"POSITION"]
              top = top +1
              
            }
            if( tab_pval[i,4] == "forestgreen" & tab_pval[i+1,4] == "forestgreen" & tab_pval[i-1,4] != "forestgreen" & top == 1){
              max = tab_pval[i,"POSITION"]
              top = top + 1
              
            }
            
            if(top == 2){
              if (flag == 0){
                if ( etat == 2 * compt){
                  STATE = "DELAYED"
                } else if (etat == -1 * compt){
                  STATE = "ADVANCED"
                }else{
                  STATE = "ADVANCED & DELAYED"
                }
                tab_coord_dif = rbind(tab_coord_dif, c(CHR = chr,START = min,END = max, STATE = STATE))
                top = 0
                compt = 0
                etat = 0
                test = c(test, etat)
              }
              if (flag == 1){
                if ( etat == 2 * compt){
                  STATE = "DELAYED"
                } else if (etat == -1 * compt){
                  STATE = "ADVANCED"
                }else{
                  STATE = "ADVANCED & DELAYED"
                }
                tab_coord_dif = rbind(tab_coord_dif, c(CHR = chr,START = min,END = max, STATE = STATE))
                min = min2
                top = 1
                flag = 0
                compt = 0
                etat = 0
                test = c(test, etat)
              }
            }
          }
          
          inter = tab_coord_dif[tab_coord_dif[,1]== chr,]
          if (is.vector(inter) == TRUE)
            inter = matrix (inter,1,3)
          debut1 = NULL
          debut2 = NULL
          delayed = NULL
          advanced = NULL
          inter = as.data.frame(inter)
          inter_ad = inter[inter$STATE == "ADVANCED",]
          if (dim(inter_ad)[1] != 0){
            debut1 = as.numeric(as.character(inter_ad[,2]))
            fin1 = as.numeric(as.character(inter_ad[,3]))
          }
          
          
          inter_de = inter[inter$STATE == "DELAYED",]
          if(dim(inter_de)[1] != 0){
            debut2 = as.numeric(as.character(inter_de[,2]))
            fin2 = as.numeric(as.character(inter_de[,3]))
          }

          # Vector "debut1" : add the missing position if it exists (for the first value when top < 2)
          if (!is.null(debut1) && is.na(debut1[1])){
            debut1[1] <- pos.0.advanced
          }
          
          if (!is.null(debut1[1])){
            if(debut1[1] == 0){
              debut1[1] = mean(c(All_data1$POSITION[1], All_data2$POSITION[1]))
            }
          }

          # Vector "debut2" : add the missing position if it exists (for the first value when top < 2)
          if (!is.null(debut2) && is.na(debut2[1])){
            debut2[1] <- pos.0.delayed
          }
          
          if (!is.null(debut2[1])){
            if(debut2[1] == 0){
              debut2[1] = mean(c(All_data1$POSITION[1], All_data2$POSITION[1]))
            }
          }
          
          if(!is.null(debut1)){
            if (organisme == "Human"){
              # advanced = cbind(debut1, fin1)
              advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
            } else if (organisme == "noCentromere"){
              advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
              # advanced = cbind((debut1 + Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos) ,(fin1+ Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos) )
              # advanced = cbind((debut1 + (fin1-debut1)/2),(fin1+ (fin1-debut1)/2))
            } else {
              advanced = cbind((debut1 + overlap *  moyenne_entre_pos)  , (fin1 + overlap *  moyenne_entre_pos ))
            }
          }
          if(!is.null(debut2)){
            if (organisme == "Human"){
              # delayed= cbind(debut2, fin2)
              delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
            } else if (organisme == "noCentromere"){
              delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
              # delayed= cbind((debut2 + Loess_data1$POSITION[1] - All_data1$POSITION[1] + overlap *  moyenne_entre_pos), (fin2+ Loess_data1$POSITION[1]- All_data1$POSITION[1] + overlap *  moyenne_entre_pos))
              # delayed= cbind((debut2 + (fin2-debut2)/2 ), (fin2 + (fin2-debut2)/2))
            } else {
              delayed= cbind((debut2 + overlap *  moyenne_entre_pos), (fin2 + overlap *  moyenne_entre_pos))
            }
          }
          
          if(dim(delayed)[1] == 0 && !is.null(delayed))
            delayed = rbind(delayed, c(NA,NA))
          if(dim(advanced)[1] == 0 && !is.null(advanced))
            advanced = rbind(delayed, c(NA,NA))
        }
        
        Loess_data1_1 = Loess_data1[which(Loess_data1[,6] == 1 ), ]
        Loess_data1_2 = Loess_data1[which(Loess_data1[,6] == 2 ), ]
        Loess1m = c( Loess_data1_1$RTlc.fitted, NA,  Loess_data1_2$RTlc.fitted)
        Loess1p = c( Loess_data1_1$POSITION, NA,  Loess_data1_2$POSITION)
        
        Loess_data2_1 = Loess_data2[which(Loess_data2[,6] == 1 ), ]
        Loess_data2_2 = Loess_data2[which(Loess_data2[,6] == 2 ), ]
        
        Loess2m = c( Loess_data2_1$RTlc.fitted, NA,  Loess_data2_2$RTlc.fitted)
        Loess2p = c( Loess_data2_1$POSITION, NA,  Loess_data2_2$POSITION)
        
        #=======================================================================
        # Euclidean method
        #=======================================================================
        
        if (type_dif == "Euclidean method"){
          px <- (Loess_data1$RTlc.fitted - Loess_data2$RTlc.fitted)**2
          b = boxplot(px, plot = F)
          
          color = rep('blue', length(px))
          color[which(px >= b$stats[5])] = "red"
          layout(matrix(c(1,2), 1, 2, byrow = TRUE),
                 widths=c(10,1))
          par(mar = c(5, 4, 4, 0) + 0.1)
          px <- (Loess_data1$RTlc.fitted - Loess_data2$RTlc.fitted)**2
          plot(px~Loess_data1$POSITION, col = color, pch = 20, axes = F, ylim= c(0,1),
               ylab = "Difference squared", xlab = "Position in pb")
          axis(1)
          axis(2, c(seq(0,1.75,0.25)))
          abline(h= min(b$out), col = 'red', lwd = 2, lty = 2)
          abline(h = (0.67)**2)
          par(mar = c(5, 0, 4, 2) + 0.1)
          boxplot(px, axes = F, col = "blue", outcol = "red", pch = 20,ylim= c(0,1))
          b = boxplot(px, plot = F)
          
          if (input$ET_CB){ # if automatic is true
            seuil = b$stats[5,1]
          } else {
            seuil = input$num_NP
          }
          
          dif = c(which( px <= b$stats[1,1]), which(px >= seuil)) #b$stats[5,1]
          dif = sort(dif)
          
          sous = diff(dif)
          difference = NULL
          start = dif[1]
          for (boucle in 1:length(sous)){
            if(sous[boucle] != 1){
              end = dif[boucle]
              difference = rbind(difference, c(start,end))
              if(boucle != length(dif) )
                start =  dif[boucle + 1]
            }
            
            if(boucle == length(dif)){
              end = dif[boucle]
              difference = rbind(difference, c(start,end))
            }
            
          }
          
          ### New search
          sous = diff(dif)
          difference = NULL
          start = dif[1]
          compteur = 1
          for (boucle in 1:length(sous)){
            
            if(sous[boucle] == 1){
              compteur = compteur +1
            }
            
            if(sous[boucle] != 1){
              if( compteur == 1 ){ # change in function of size
                start = dif[boucle]
              } else{
                end = dif[boucle]
                difference = rbind(difference, c(start,end))
                if(boucle != length(dif) )
                  start =  dif[boucle + 1]
              }
              compteur = 1
            }
            
            if(boucle == length(dif)){
              end = dif[boucle]
              difference = rbind(difference, c(start,end))
            }
            
          }
          
          advanced = NULL
          delayed = NULL
          if (is.null(difference) == F){
            for(t in 1:dim(difference)[1]){
              moy1 = (All_data1$mLymphAve[difference[t,1]]+All_data1$mLymphAve[difference[t,2]])/2
              moy2 = (All_data2$mLymphAve[difference[t,1]]+All_data2$mLymphAve[difference[t,2]])/2
              if (moy1 < moy2)
                advanced = rbind(advanced,c(All_data2$POSITION[difference[t,1]],All_data2$POSITION[difference[t,2]]))
              else
                delayed = rbind(delayed,c(All_data2$POSITION[difference[t,1]],All_data2$POSITION[difference[t,2]]))
            }
            
            delayed_point = delayed
            advanced_point = advanced
          }
        }
        
        ## Image
        minus = round((min(min(All_data2$mLymphAve), min(All_data1$mLymphAve))-0.5))
        maxi = round(max(max(All_data2$mLymphAve), max(All_data1$mLymphAve)+ 0.5))
        
        if(sortie_image == "Yes"){
          filename = paste("Differential/Differential_",chr,"_",pv3,"_",num,".pdf",sep="")
          pdf(filename )
          
          plot(All_data1$POSITION, All_data1$mLymphAve, ylab = "Intensity", xlab="Coordinate (bp)",
               cex = 0.5, pch = 16, col = "gray80", main = paste("Differential (", chr,")"),  ylim = c(minus,maxi))
          points(All_data2$POSITION, All_data2$mLymphAve, cex = 0.5, pch = 16, col = "gray80")
          lines(Loess1m~Loess1p, col="blue3", lwd=3)
          lines(Loess2m~Loess2p, col="red", lwd=3)
          
          if (is.null(advanced) != T){
            segments(advanced[,1], minus, advanced[,2], minus, col = "coral", lwd=3)
          }
          
          if (is.null(delayed) != T){
            segments(delayed[,1], minus, delayed[,2], minus, col = "dodgerblue", lwd=3)
          }
          
          legend("topright", legend = c("Exp. 1", "Exp. 2", "Advanced", "Delayed"), col = c("blue", "red", "coral", "dodgerblue"), lty = 1, inset = 0.01, box.lty = 0, title = "Legends")
          
          dev.off()
        }
        
        
        ########################################################################
        # Plotly
        ########################################################################
        
        # General
        varg1 = " var trace1 = {
        x:["
        vary  =
          " ] ,y: ["
        vargo1  = "],
        mode: 'markers',
        marker: {
        color : 'gray80'
        },
        opacity : 0.2,
        name : 'Exp 1'
      };"
        
        varg2 = " var trace2 = {
        x:["
        
        vargo2  = "],
        mode: 'markers',
        marker: {
        color : 'gray79'
        },
        opacity : 0.2,
        name : 'Exp 2'
    };"
        
        
        # Loess
        var1 = " var trace3 = {
        x:["
        
        var1o = "],
        mode: 'lines',
        line: {
        color: 'blue',
        width : 2
        },
        name : 'Smooth Exp 1'
        };"
        
        var2 = " var trace4 = {
        x:["
        
        var2o = "],
        mode: 'lines',
        line: {
        color: 'red',
        width : 2
        },
        name : 'Smooth Exp 2'
        };"
        
        # seg advanced
        var3 = " var trace5 = {
        x:["
        
        var3o = "],
        mode: 'lines',
        line : {
        color: 'forestgreen',
        width : 5
        },
        name : 'Advanced'
    };
        "
        
        # seg advanced
        var4 = " var trace6 = {
        x:["
        
        var4o = "],
        mode: 'lines',
        line : {
        color: 'magenta',
        width : 5
        },
        name : 'Delayed'
          };
        "
        
        data = " var data = [ trace1, trace2, trace3, trace4, trace5, trace6];"
        
        layout = paste(" var layout = {
                       title:'Differential study for ", chr,"',
                       xaxis: {
                       title: 'Position (pb)'},
                       yaxis: {
                       title: 'Intensity'}
  };", sep = "")
        
        # General
        filename = paste("Differential/Viewer/",chr,".js",sep="")
        write(varg1, filename)
        write.table( t(All_data1$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( t(All_data1$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vargo1, filename, append = T)
        
        # General2
        write( varg2, filename, append = T)
        write.table( t(All_data2$POSITION), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( t(All_data2$mLymphAve), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vargo2, filename, append = T)
        
        # Loess1
        write( var1, filename,  append = T)
        write.table(recode(t(Loess1p), "NA ='NaN'") , filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( recode(t(Loess1m), "NA ='NaN'"), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( var1o, filename, append = T)
        
        # Loess2
        write( var2, filename,  append = T)
        write.table(recode(t(Loess2p), "NA ='NaN'"), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( recode(t(Loess2m), "NA ='NaN'"), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( var2o, filename, append = T)
        
        # Seg advanced
        pos_seg = matrix("NaN",length(advanced[,1]), 3)
        pos_seg[,1] = advanced[,1]
        pos_seg[,2] = advanced[,2]
        pos_seg = as.vector(t(pos_seg))
        
        moyen = matrix("NaN",length(advanced[,1]), 3)
        moyen[,1] = minus
        moyen[,2] = minus
        moyen = as.vector(t(moyen))
        
        write( var3, filename, append = T)
        write.table(  t(pos_seg), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( t(moyen), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( var3o, filename, append = T)
        
        global_table_viewer = rbind(
          c("Position", "Intensity", "Name"),
          cbind(as.numeric(t(All_data1$POSITION)), as.numeric(t(All_data1$mLymphAve)), "Exp 1"),
          cbind(as.numeric(t(All_data2$POSITION)), as.numeric(t(All_data2$mLymphAve)), "Exp 2"),
          cbind(as.numeric(recode(t(Loess1p), "NA ='NaN'")), as.numeric(recode(t(Loess1m), "NA ='NaN'")), "Smooth Exp 1"),
          cbind(as.numeric(recode(t(Loess2p), "NA ='NaN'")), as.numeric( recode(t(Loess2m), "NA ='NaN'")), "Smooth Exp 2")
        )
        
        if(length(pos_seg) != 0){
          global_table_viewer = rbind(global_table_viewer,
                                      cbind(as.numeric(t(pos_seg)), as.numeric(t(moyen)), "Advanced"))
        }
        
        # Seg Delayed
        
        pos_seg = matrix("NaN",length(delayed[,1]), 3)
        pos_seg[,1] = delayed[,1]
        pos_seg[,2] = delayed[,2]
        pos_seg = as.vector(t(pos_seg))
        
        moyen = matrix("NaN",length(delayed[,1]), 3)
        moyen[,1] = minus
        moyen[,2] = minus
        moyen = as.vector(t(moyen))
        
        write( var4, filename, append = T)
        write.table( t(pos_seg), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( vary, filename, append = T)
        write.table( t(moyen), filename, append = T, sep = ",", col.names = F, row.names = F)
        write( var4o, filename, append = T)
        
        write( data, filename, append = T)
        write( layout, filename, append = T)
        write("Plotly.plot('plot', data, layout); " , filename, append = T)
        
        if(length(pos_seg) != 0){
          global_table_viewer = rbind(global_table_viewer,
                                      cbind(as.numeric(t(pos_seg)), as.numeric(t(moyen)), "Delayed"))
        }
        
        
        # General - Shiny viewer
        sink(paste0("Differential/Viewer/",chr,".SRV"))
        
        # add important informations
        # norm intre, inter rep, inter exp,
        write.table(cbind(nor1,nor2,nor3,type_dif, organisme, v4, chr),
                    row.names=FALSE,col.names=FALSE,sep="\t", quote = F)
        
        write.table(global_table_viewer, row.names=FALSE,col.names=FALSE,sep="\t", quote = F)
        
        sink()
        
        
        if(is.null(advanced) == F){
          advanced = as.data.frame(cbind(rep(chr, dim(advanced)[1]), advanced, rep("ADVANCED", dim(advanced)[1])))
          names(advanced) = c("CHR","START", "END", "STATUS")
          #if (input$analysis == "microarray"){
              #advanced$START <- round(as.numeric(advanced$START))
              #advanced$END <- round(as.numeric(advanced$END))
          #}
        }
        if(is.null(delayed) == F){
          delayed = as.data.frame(cbind(rep(chr, dim(delayed)[1]), delayed, rep("DELAYED", dim(delayed)[1])))
          names(delayed) = c("CHR","START", "END", "STATUS")
          #if (input$analysis == "microarray"){
            #delayed$START <- round(as.numeric(delayed$START))
            #delayed$END <- round(as.numeric(delayed$END))
          #}
        }
        
        
        
        ALL_dif = rbind(ALL_dif, advanced)
        ALL_dif = rbind(ALL_dif, delayed)
        
        
        ########################################################################
        # A- Percent changes analysis
        ########################################################################
        
        max = max(as.numeric(as.character(RTb$POSITION)))
        dif = c(as.numeric(as.character(advanced[,3])) - as.numeric(as.character(advanced[,2])),
                as.numeric(as.character(delayed[,3])) - as.numeric(as.character(delayed[,2])))
        sum = sum(dif)
        max_tot = max_tot + max
        sum_tot = sum_tot + sum
        pourcentage = sum*100/max
        tab_pourcentage = rbind(tab_pourcentage, c(chr,pourcentage))
      }
      
      if (input$analysis == "microarray"){
        ALL_dif <- t(apply(ALL_dif, 1, function(x) round.positions(x)))
      }

      filename = paste("Differential/Differential_position_",num,".txt",sep="")
      write.table( ALL_dif,filename, row.names=F, quote=F, sep="\t")
      filename = paste("Differential/Differential_position_",num,".bed",sep="")
      write.table( ALL_dif,filename, row.names=F, quote=F, col.names = F, sep="\t")
      
      pourcentage_tot = sum_tot *100/max_tot
      tab_pourcentage = tab_pourcentage[order(tab_pourcentage[,2]),]
      tab_pourcentage = rbind(tab_pourcentage, c("Total",pourcentage_tot))
      colnames(tab_pourcentage) = c("chrom", "percentage")
      filename = paste("Differential/Differential_percentage_",num,".txt",sep="")
      write.table(tab_pourcentage,filename, row.names=F, quote=F, sep="\t")
      
    }

    #///////////////////////////////////////////////////////////////////////////
    # Creating a codebook
    #///////////////////////////////////////////////////////////////////////////
    
    ###############################
    codebook = NULL
    codebook = rbind(codebook, c("File 1 : ",File1name))
    codebook = rbind(codebook, c("File 2 : ",File2name))
    codebook = rbind(codebook, c("File 3 : ",File3name))
    codebook = rbind(codebook, c("File 4 : ",File4name))
    if (input$analysis == "microarray"){
      codebook = rbind(codebook, c("Total number of lines : ", nbr.total))
      codebook = rbind(codebook, c("Number of removed lines : ", nbr.remove))
      codebook = rbind(codebook, c("Percentage of removed lines (%) : ", percentage.remove))
    }
    codebook = rbind(codebook, c("Organism : ",organisme))
    codebook = rbind(codebook, c("Sortie image : ",sortie_image))
    codebook = rbind(codebook, c("Bed : ",bed))
    codebook = rbind(codebook, c("Intra array : ",nor1))
    codebook = rbind(codebook, c("Inter replica : ",nor2))
    codebook = rbind(codebook, c("Inter experiment : ",nor3))
    codebook = rbind(codebook, c("Smooth : ",e1))
    codebook = rbind(codebook, c("TTR : ",e2))
    codebook = rbind(codebook, c("Segmentation : ",e3))
    codebook = rbind(codebook, c("All : ",e4))
    
    codebook = rbind(codebook, c("Differential analysis : ",e5))
    
    if (differential.analysis == TRUE && input$analysis == "repliseq"){
      codebook = rbind(codebook, c("Total number of lines : ", nbr.total))
      codebook = rbind(codebook, c("Number of removed lines : ", nbr.remove))
      codebook = rbind(codebook, c("Percentage of removed lines (%) : ", percentage.remove))
    }
    codebook = rbind(codebook, c("Span : ",v1))
    codebook = rbind(codebook, c("Number of SD : ",v2))
    codebook = rbind(codebook, c("padjust : ",v3))
    codebook = rbind(codebook, c("Smooth method : ",v4))
    codebook = rbind(codebook, c("Size : ",v5))
    codebook = rbind(codebook, c("Number of lines to skip : ",fs1))
    codebook = rbind(codebook, c("Column name of green signal : ",fs2))
    codebook = rbind(codebook, c("Column name of red signal : ",fs3))
    codebook = rbind(codebook, c("Early fraction : ",fs4))
    codebook = rbind(codebook, c("Late fraction : ",fs5))
    ###############################

    if(e5){
      codebook = rbind(codebook, c("Difference type : ",type_dif))
      if(input$select_method_differential == "Mean method" && input$select_method_pvalue == "Manual pvalue"){
        codebook = rbind(codebook, c("P-value threshold : ",pv1))
        codebook = rbind(codebook, c("Window size : ",pv2))
        codebook = rbind(codebook, c("Adjusted Pvalue : ",pv3))
        codebook = rbind(codebook, c("Overlap : ",pv4))
      }
    }

    if(input$select_method_differential == "Mean method" && input$select_method_pvalue == "Automatic pvalue"){
      codebook = rbind(codebook, c("Method of automatic detection : ", input$select_method_automatic))
      codebook = rbind(codebook, c("P-value threshold : ", pv1))
      codebook = rbind(codebook, c("Window size : ", pv2))
      codebook = rbind(codebook, c("Adjusted Pvalue : ", pv3))
      codebook = rbind(codebook, c("Overlap : ", pv4))
    }
    
    if(input$select_method_differential == "Euclidean method"){
      codebook = rbind(codebook, c("Threshold difference (euclidienne): ",type_dif))
      if(input$ET_CB){
        codebook = rbind(codebook, c("Empirical threshold (euclidienne): ",paste(seuil,"(automatic)")))
      } else {
        codebook = rbind(codebook, c("Empirical threshold (euclidienne): ",paste(seuil,"(non-automatic)")))
      }
    }

    # Writing the codebook in the folder
    write.table(codebook, "codebook.txt", quote = F,
                col.names = F, row.names = F)
    
    setwd("../..")
    
    # After
    hideElement(id = "H1_processing")
    hideElement(id = "img_processing")
    hideElement(id = "Processing")
    hideElement(id = "timer")
    
    showElement(id = "img_end")
    showElement(id = "End")
  })
  
  output$beginTime <- renderText({
    begin = Sys.time()
    paste0("(The analysis started at : ",format(Sys.time(), "%X"),")")
  })
  
  output$endTime <- renderText({
    
    time = difftime(Sys.time(), begin, units='secs')
    minutes = trunc(time/60)
    secondes = trunc(time - minutes * 60);
    
    paste("The analysis has taken : ", minutes, "mins.",
          secondes, 'secs' )
  })
  
}

shinyApp(ui, server)
